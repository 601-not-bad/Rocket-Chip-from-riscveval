diff --git a/arch/Kconfig b/arch/Kconfig
index 5952be3..d71db9a 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -38,6 +38,10 @@ config NIOS2
 	bool "Nios II Gen 2 architecture"
 	select ATOMIC_OPERATIONS_C
 
+config RISCV64
+	bool "RISC-V 64-bits architecture"
+	select ATOMIC_OPERATIONS_C
+
 endchoice
 
 #
diff --git a/arch/msvc/core/device_link.h b/arch/msvc/core/device_link.h
new file mode 100644
index 0000000..2c56c4b
--- /dev/null
+++ b/arch/msvc/core/device_link.h
@@ -0,0 +1,58 @@
+#ifndef __DEVICE_LINK_H__
+#define __DEVICE_LINK_H__
+
+#define DEVICE_INIT(dev_name, drv_name, init_fn, data, cfg_info, level, prio) \
+	\
+	static struct device_config __config_ ## dev_name = \
+	{   \
+		drv_name,   \
+        init_fn,    \
+		cfg_info    \
+	};  \
+	struct device __device_ ## dev_name = {      \
+		 &__config_ ## dev_name,   \
+         NULL,  \
+		 data   \
+	}
+
+    typedef enum enum_init_start {
+        init_start_Total = 0
+    } enum_init_start;
+
+    typedef enum enum_PRIMARY {
+        DEVICE_Soc = init_start_Total,
+        DEVICE_Uart,
+        PRIMARY_Total
+    } enum_PRIMARY;
+
+    typedef enum enum_SECONDARY {
+        DEVICE_SysClock = PRIMARY_Total,
+        DEVICE_UartConsole,
+        SECONDARY_Total
+    } enum_SECONDARY;
+
+    typedef enum enum_NANOKERNEL {
+        DEVICE_SyskEventLogger = SECONDARY_Total,
+        NANOKERNEL_Total
+    } enum_NANOKERNEL;
+
+    typedef enum enum_MICROKERNEL {
+        MICROKERNEL_Total = NANOKERNEL_Total
+    } enum_MICROKERNEL;
+
+    typedef enum enum_APPLICATION {
+        APPLICATION_Total = MICROKERNEL_Total
+    } enum_APPLICATION;
+
+
+extern struct device zephyr_devices[];
+
+#define __device_init_start (&zephyr_devices[0])
+#define __device_PRIMARY_start (&zephyr_devices[init_start_Total])
+#define __device_SECONDARY_start (&zephyr_devices[PRIMARY_Total])
+#define __device_NANOKERNEL_start (&zephyr_devices[SECONDARY_Total])
+#define __device_MICROKERNEL_start (&zephyr_devices[NANOKERNEL_Total])
+#define __device_APPLICATION_start (&zephyr_devices[MICROKERNEL_Total])
+#define __device_init_end (&zephyr_devices[APPLICATION_Total])
+
+#endif  // __DEVICE_LINK_H__
diff --git a/arch/msvc/core/entry_point.c b/arch/msvc/core/entry_point.c
new file mode 100644
index 0000000..c1791fb
--- /dev/null
+++ b/arch/msvc/core/entry_point.c
@@ -0,0 +1,52 @@
+#include <string.h>
+#include <device.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+
+
+extern void __printk_hook_install(int (*fn)(int));
+extern void __stdout_hook_install(int (*fn)(int));
+extern void LIBH_create_dispatcher(void *entry_point);
+extern int LIBH_uart_output(int v);
+
+
+struct device *config_levels[6];
+
+// init
+// None
+// PRIMARY
+extern struct device __device_sys_init_riscv_gnss_soc_init;
+extern struct device __device_uart_gnss0;
+// SECONDARY
+extern struct device __device_sys_init_uart_console_init;// CONFIG_EARLY_CONSOLE is disabled
+// NANOKERNEL
+extern struct device __device_sys_init__sys_clock_driver_init;
+extern struct device __device_sys_init__sys_k_event_logger_init;
+
+struct device zephyr_devices[16] = {0
+};
+
+extern FUNC_NORETURN void _Cstart(void);
+
+char __bss_start[16];
+char *__bss_end = __bss_start + 16;
+
+
+int BaseAddress_0x40000000(int argc, char *argv[]) {
+
+    //__printk_hook_install(LIBH_uart_output);
+    //__stdout_hook_install(LIBH_uart_output);
+
+    zephyr_devices[DEVICE_Soc] = __device_sys_init_riscv_gnss_soc_init;
+    zephyr_devices[DEVICE_Uart] = __device_uart_gnss0;
+    zephyr_devices[DEVICE_SysClock] = __device_sys_init__sys_clock_driver_init;
+    zephyr_devices[DEVICE_UartConsole] = __device_sys_init_uart_console_init;
+    zephyr_devices[DEVICE_SyskEventLogger] = __device_sys_init__sys_k_event_logger_init;
+
+    LIBH_create_dispatcher(_Cstart);
+        
+
+    //printk("Hello %s\n", "World");
+   
+    return 0;
+}
\ No newline at end of file
diff --git a/arch/msvc/core/func_alias/compiler_stack_protect_alias.c b/arch/msvc/core/func_alias/compiler_stack_protect_alias.c
new file mode 100644
index 0000000..82e8670
--- /dev/null
+++ b/arch/msvc/core/func_alias/compiler_stack_protect_alias.c
@@ -0,0 +1,8 @@
+#include <nanokernel.h>
+
+extern void _StackCheckHandler(void);
+
+void __stack_chk_fail(void)
+{
+    _StackCheckHandler();
+}
diff --git a/arch/msvc/core/func_alias/nano_fiber_alias.c b/arch/msvc/core/func_alias/nano_fiber_alias.c
new file mode 100644
index 0000000..8762328
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_fiber_alias.c
@@ -0,0 +1,63 @@
+#include <nanokernel.h>
+
+extern nano_thread_id_t _fiber_start(char *pStack,
+		unsigned stackSize, /* stack size in bytes */
+		nano_fiber_entry_t pEntry,
+		long parameter1,
+		long parameter2,
+		unsigned priority,
+		unsigned options);
+
+
+nano_thread_id_t fiber_fiber_start(char *pStack,
+		unsigned stackSize, nano_fiber_entry_t pEntry, long parameter1,
+		long parameter2, unsigned priority, unsigned options)
+{
+    return _fiber_start(pStack, stackSize, pEntry, parameter1, parameter2,
+	        priority, options);
+}
+nano_thread_id_t task_fiber_start(char *pStack,
+	unsigned stackSize,  nano_fiber_entry_t pEntry, long parameter1,
+	long parameter2, unsigned priority, unsigned options)
+{
+    return _fiber_start(pStack, stackSize, pEntry, parameter1, parameter2,
+		        priority, options);
+}
+
+nano_thread_id_t fiber_start(char *pStack,
+	unsigned stackSize,  nano_fiber_entry_t pEntry, long parameter1,
+	long parameter2, unsigned priority, unsigned options)
+{
+    return _fiber_start(pStack, stackSize, pEntry, parameter1, parameter2,
+		        priority, options);
+}
+
+nano_thread_id_t fiber_fiber_delayed_start(char *stack,
+			  unsigned int stack_size_in_bytes,
+			  nano_fiber_entry_t entry_point, long param1,
+			  long param2, unsigned int priority,
+			  unsigned int options, int32_t timeout_in_ticks)
+{
+    return fiber_delayed_start(stack, stack_size_in_bytes, entry_point, param1,
+			  param2, priority, options, timeout_in_ticks);
+}
+
+nano_thread_id_t task_fiber_delayed_start(char *stack,
+			  unsigned int stack_size_in_bytes,
+			  nano_fiber_entry_t entry_point, long param1,
+			  long param2, unsigned int priority,
+			  unsigned int options, int32_t timeout_in_ticks)
+{
+    return fiber_delayed_start(stack, stack_size_in_bytes, entry_point, param1,
+			  param2, priority, options, timeout_in_ticks);
+}
+
+void fiber_fiber_delayed_start_cancel(nano_thread_id_t handle)
+{
+    fiber_delayed_start_cancel(handle);
+}
+void task_fiber_delayed_start_cancel(nano_thread_id_t handle)
+{
+    fiber_delayed_start_cancel(handle);
+}
+
diff --git a/arch/msvc/core/func_alias/nano_fifo_alias.c b/arch/msvc/core/func_alias/nano_fifo_alias.c
new file mode 100644
index 0000000..92b8fa4
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_fifo_alias.c
@@ -0,0 +1,52 @@
+#include <nanokernel.h>
+
+extern void _fifo_put_non_preemptible(struct nano_fifo *fifo, void *data);
+extern void _fifo_put_list_non_preemptible(struct nano_fifo *fifo,
+				    void *head, void *tail);
+extern void _fifo_put_slist_non_preemptible(struct nano_fifo *fifo,
+				     sys_slist_t *list);
+extern void *_fifo_get(struct nano_fifo *fifo, int32_t timeout_in_ticks);
+
+void nano_isr_fifo_put(struct nano_fifo *fifo, void *data)
+{
+    _fifo_put_non_preemptible(fifo, data);
+}
+
+void nano_fiber_fifo_put(struct nano_fifo *fifo, void *data)
+{
+    _fifo_put_non_preemptible(fifo, data);
+}
+
+void nano_isr_fifo_put_list(struct nano_fifo *fifo,
+				    void *head, void *tail)
+{
+    _fifo_put_list_non_preemptible(fifo, head, tail);
+}
+
+void nano_fiber_fifo_put_list(struct nano_fifo *fifo,
+				    void *head, void *tail)
+{
+    _fifo_put_list_non_preemptible(fifo, head, tail);
+}
+
+void nano_isr_fifo_put_slist(struct nano_fifo *fifo,
+				     sys_slist_t *list)
+{
+    _fifo_put_slist_non_preemptible(fifo, list);
+}
+
+void nano_fiber_fifo_put_slist(struct nano_fifo *fifo,
+				     sys_slist_t *list)
+{
+    _fifo_put_slist_non_preemptible(fifo, list);
+}
+
+void *nano_isr_fifo_get(struct nano_fifo *fifo, int32_t timeout_in_ticks)
+{
+    return _fifo_get(fifo, timeout_in_ticks);
+}
+
+void *nano_fiber_fifo_get(struct nano_fifo *fifo, int32_t timeout_in_ticks)
+{
+    return _fifo_get(fifo, timeout_in_ticks);
+}
diff --git a/arch/msvc/core/func_alias/nano_lifo_alias.c b/arch/msvc/core/func_alias/nano_lifo_alias.c
new file mode 100644
index 0000000..5700a4d
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_lifo_alias.c
@@ -0,0 +1,24 @@
+#include <nanokernel.h>
+
+extern void _lifo_put_non_preemptible(struct nano_lifo *lifo, void *data);
+extern void *_lifo_get(struct nano_lifo *lifo, int32_t timeout_in_ticks);
+
+void nano_isr_lifo_put(struct nano_lifo *lifo, void *data)
+{
+    _lifo_put_non_preemptible(lifo, data);
+}
+
+void nano_fiber_lifo_put(struct nano_lifo *lifo, void *data)
+{
+    _lifo_put_non_preemptible(lifo, data);
+}
+
+void *nano_isr_lifo_get(struct nano_lifo *lifo, int32_t timeout_in_ticks)
+{
+    return _lifo_get(lifo, timeout_in_ticks);
+}
+
+void *nano_fiber_lifo_get(struct nano_lifo *lifo, int32_t timeout_in_ticks)
+{
+    return _lifo_get(lifo, timeout_in_ticks);
+}
diff --git a/arch/msvc/core/func_alias/nano_sema_alias.c b/arch/msvc/core/func_alias/nano_sema_alias.c
new file mode 100644
index 0000000..5cdd707
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_sema_alias.c
@@ -0,0 +1,25 @@
+#include <nano_private.h>
+#include <wait_q.h>
+
+extern void _sem_give_non_preemptible(struct nano_sem *sem);
+extern int _sem_take(struct nano_sem *sem, int32_t timeout_in_ticks);
+
+void nano_isr_sem_give(struct nano_sem *sem)
+{
+    _sem_give_non_preemptible(sem);
+}
+
+void nano_fiber_sem_give(struct nano_sem *sem)
+{
+    _sem_give_non_preemptible(sem);
+}
+
+int nano_isr_sem_take(struct nano_sem *sem, int32_t timeout_in_ticks)
+{
+    return _sem_take(sem, timeout_in_ticks);
+}
+
+int nano_fiber_sem_take(struct nano_sem *sem, int32_t timeout_in_ticks)
+{
+    return _sem_take(sem, timeout_in_ticks);
+}
diff --git a/arch/msvc/core/func_alias/nano_sleep_alias.c b/arch/msvc/core/func_alias/nano_sleep_alias.c
new file mode 100644
index 0000000..0830065
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_sleep_alias.c
@@ -0,0 +1,21 @@
+#include <nanokernel.h>
+
+extern void _fiber_wakeup(nano_thread_id_t fiber);
+extern void _nano_task_sleep(int32_t timeout_in_ticks);
+
+void isr_fiber_wakeup(nano_thread_id_t fiber)
+{
+    _fiber_wakeup(fiber);
+}
+
+void fiber_fiber_wakeup(nano_thread_id_t fiber)
+{
+    _fiber_wakeup(fiber);
+}
+
+#ifndef CONFIG_MICROKERNEL
+void task_sleep(int32_t timeout_in_ticks)
+{
+    _nano_task_sleep(timeout_in_ticks);
+}
+#endif
diff --git a/arch/msvc/core/func_alias/nano_stack_alias.c b/arch/msvc/core/func_alias/nano_stack_alias.c
new file mode 100644
index 0000000..417f16b
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_stack_alias.c
@@ -0,0 +1,23 @@
+#include <nano_private.h>
+extern void _stack_push_non_preemptible(struct nano_stack *stack, uint32_t data);
+extern int _stack_pop(struct nano_stack *stack, uint32_t *pData, int32_t timeout_in_ticks);
+
+void nano_isr_stack_push(struct nano_stack *stack, uint32_t data)
+{
+    _stack_push_non_preemptible(stack, data);
+}
+void nano_fiber_stack_push(struct nano_stack *stack, uint32_t data)
+{
+    _stack_push_non_preemptible(stack, data);
+}
+
+int nano_isr_stack_pop(struct nano_stack *stack, 
+                       uint32_t *pData, int32_t timeout_in_ticks)
+{
+    return _stack_pop(stack, pData, timeout_in_ticks);
+}
+int nano_fiber_stack_pop(struct nano_stack *stack, 
+                         uint32_t *pData, int32_t timeout_in_ticks)
+{
+    return _stack_pop(stack, pData, timeout_in_ticks);
+}
diff --git a/arch/msvc/core/func_alias/nano_timer_alias.c b/arch/msvc/core/func_alias/nano_timer_alias.c
new file mode 100644
index 0000000..835acf8
--- /dev/null
+++ b/arch/msvc/core/func_alias/nano_timer_alias.c
@@ -0,0 +1,38 @@
+
+#include <nanokernel.h>
+extern void _timer_start(struct nano_timer *timer, int ticks);
+extern void _timer_stop_non_preemptible(struct nano_timer *timer);
+extern void _timer_stop_non_preemptible(struct nano_timer *timer);
+
+void nano_isr_timer_start(struct nano_timer *timer, int ticks)
+{
+    _timer_start(timer, ticks);
+}
+
+void nano_fiber_timer_start(struct nano_timer *timer, int ticks)
+{
+    _timer_start(timer, ticks);
+}
+
+void nano_task_timer_start(struct nano_timer *timer, int ticks)
+{
+    _timer_start(timer, ticks);
+}
+
+void nano_timer_start(struct nano_timer *timer, int ticks)
+{
+    _timer_start(timer, ticks);
+}
+
+
+void nano_isr_timer_stop(struct nano_timer *timer)
+{
+    _timer_stop_non_preemptible(timer);
+}
+
+void nano_fiber_timer_stop(struct nano_timer *timer)
+{
+    _timer_stop_non_preemptible(timer);
+}
+
+
diff --git a/arch/msvc/core/offsets.h b/arch/msvc/core/offsets.h
new file mode 100644
index 0000000..9300c37
--- /dev/null
+++ b/arch/msvc/core/offsets.h
@@ -0,0 +1,3 @@
+#ifndef __OFFSETS_H__
+#define __OFFSETS_H__
+#endif  // __OFFSETS_H__
diff --git a/arch/msvc/core/swap.c b/arch/msvc/core/swap.c
new file mode 100644
index 0000000..1ba5fa3
--- /dev/null
+++ b/arch/msvc/core/swap.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <toolchain.h>
+#include <sections.h>
+#include <nano_private.h>
+
+extern void LIBH_swap(uint64_t tc_addr);
+extern void LIBH_swap_preemptive(uint64_t tc_addr);
+
+//
+void *_Swap(int fl) {
+    struct tcs *current;
+    if (_nanokernel.fiber == 0) {
+        //_swap_to_the_task
+        current   = _nanokernel.task;
+    } else {
+        //_swap_to_a_fiber:
+        current   = _nanokernel.fiber;
+        _nanokernel.fiber = _nanokernel.fiber->link;
+    }
+
+    _nanokernel.current->intlock = 0;   // Cooperative switch with automatic unlocking
+    _nanokernel.current = current;
+    irq_unlock(_nanokernel.current->intlock);
+    LIBH_swap((uint64_t)_nanokernel.current);
+    return (void *)_nanokernel.current->coopReg[COOP_REG_A0/sizeof(uint64_t)];
+}
+
+void _IsrExit(void) {
+    if ((_nanokernel.current->flags & TASK) == TASK) {
+        if (_nanokernel.fiber) {
+            _nanokernel.current->intlock = _arch_irq_lock_state();
+            _nanokernel.current = _nanokernel.fiber;
+            _nanokernel.fiber = _nanokernel.fiber->link;
+
+            irq_unlock(_nanokernel.current->intlock);
+            LIBH_swap_preemptive((uint64_t)_nanokernel.current);
+        }
+    }
+}
+
+
diff --git a/arch/msvc/core/version.h b/arch/msvc/core/version.h
new file mode 100644
index 0000000..ec99167
--- /dev/null
+++ b/arch/msvc/core/version.h
@@ -0,0 +1,7 @@
+#ifndef _NANOKERNEL_VERSION_H_
+#define _NANOKERNEL_VERSION_H_
+
+// Zephyr 1.1.0
+#define KERNELVERSION ((1<<24)|(4<<16) | (0<<8))
+
+#endif  // _NANOKERNEL_VERSION_H_
diff --git a/arch/msvc/lib/dispatcher.cpp b/arch/msvc/lib/dispatcher.cpp
new file mode 100644
index 0000000..9ab2ab8
--- /dev/null
+++ b/arch/msvc/lib/dispatcher.cpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fstream>
+#include <iostream>
+#include <conio.h>
+#include "zephyr_threads.h"
+#include "irqctrl.h"
+#include "uart.h"
+#include "gptimers.h"
+#include "pnp.h"
+
+static const int IDLE_STACK_SIZE = sizeof(tcs_simple);
+static char idle_stack[IDLE_STACK_SIZE];
+IrqController irqctrl;
+Uart uart0;
+GPTimers tmr0;
+PNP pnp;
+volatile bool wasPreemtiveSwitch;
+int current_idx;
+std::vector<ThreadDataType> vecThreads;
+
+extern "C" void _SwapPreemptive(char *ctx);
+
+extern "C" void idle_task_entry(_thread_entry_t pEntry,
+					            _thread_arg_t arg1,
+					            _thread_arg_t arg2,
+					            _thread_arg_t arg3) {
+    typedef void (*epoint)(void);
+    epoint epoint_ = (epoint)pEntry;
+    epoint_();
+    printf_s("\n%s: End of thread!!\n", __FUNCTION__);
+}
+
+
+extern "C" void LIBH_create_dispatcher(void *entry_point) {
+    DWORD tmp;
+    tcs_simple *ctx = (tcs_simple *)idle_stack;
+    ctx->regs[REG_RA] = (uint64_t)idle_task_entry;
+    ctx->regs[REG_A0] = (uint64_t)entry_point;
+    LIBH_create_thread(idle_stack, IDLE_STACK_SIZE, 0, 0);
+    current_idx = 0;
+    //printf_s("Event[%d] idle_tick set\n", current_idx);
+    SetEvent(vecThreads[current_idx].hEvent);
+
+    while (1) {
+        tmp = SuspendThread(vecThreads[current_idx].hThread);
+        wasPreemtiveSwitch = false;
+
+        irqctrl.raise_interrupt(3); // GPTimer
+
+        if (_kbhit()) {
+            uart0.putRx(_getch());
+            irqctrl.raise_interrupt(1);
+        }
+
+        if (wasPreemtiveSwitch) {
+            wasPreemtiveSwitch = false;
+        } else {
+            // @retvalue 0 the specified thread was not suspended. 
+            //           1, the specified thread was suspended but was restarted. 
+            //          >1, the specified thread is still suspended.
+            tmp = ResumeThread(vecThreads[current_idx].hThread);
+        }
+
+        Sleep(100);
+    }
+}
+
diff --git a/arch/msvc/lib/gptimers.h b/arch/msvc/lib/gptimers.h
new file mode 100644
index 0000000..c3df4f6
--- /dev/null
+++ b/arch/msvc/lib/gptimers.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "imapdev.h"
+
+class GPTimers : public IMappedDevice {
+public:
+    GPTimers() {
+    }
+
+    virtual bool isAddrValid(uint64_t addr) {
+        return (addr >= 0x80005000 && addr < 0x80006000);
+    }
+    virtual void write(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80005000;
+        switch (off>>2) {
+        case 0x00:
+            break;
+        case 0x04:
+            break;
+        default:;
+        }
+
+    }
+    virtual void read(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80005000;
+        switch (off>>2) {
+        case 0x0:
+            *(uint32_t *)buf = (uint32_t)getHighticks();
+            break;
+        case 0x04:
+            *(uint32_t *)buf = (uint32_t)(getHighticks()>>32);
+            break;
+        default:;
+        }
+    }
+
+private:
+    // High-resolution timer.
+    uint64_t getHighticks() {
+      LARGE_INTEGER counter;
+      QueryPerformanceCounter(&counter);
+
+      double ticks = double(counter.QuadPart);
+      return (uint64_t)(1000*ticks);
+    }
+
+private:
+};
+
diff --git a/arch/msvc/lib/imapdev.h b/arch/msvc/lib/imapdev.h
new file mode 100644
index 0000000..7b86bb1
--- /dev/null
+++ b/arch/msvc/lib/imapdev.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <inttypes.h>
+
+class IMappedDevice {
+public:
+    virtual bool isAddrValid(uint64_t off) =0;
+};
diff --git a/arch/msvc/lib/irqctrl.h b/arch/msvc/lib/irqctrl.h
new file mode 100644
index 0000000..a1d48eb
--- /dev/null
+++ b/arch/msvc/lib/irqctrl.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "imapdev.h"
+
+class IrqController : public IMappedDevice {
+public:
+    IrqController() {
+        irq_lock_ = 0;
+        isr_mask_ = ~0;
+        isr_table_ = 0;
+    }
+
+    virtual bool isAddrValid(uint64_t addr) {
+        return (addr >= 0x80002000 && addr < 0x80003000);
+    }
+    virtual void write(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80002000;
+        switch (off) {
+        case 0x00:
+            isr_mask_ = *(uint32_t *)buf;
+            break;
+        case 0x08:
+            isr_pending_ &= ~(*(uint32_t *)buf);
+            break;
+        case 0x10:
+            isr_table_ = *((IsrEntryType **)buf);
+            break;
+        case 0x28:
+            irq_lock_ = *(uint32_t *)buf;
+            break;
+        default:
+            break;
+        }
+
+    }
+    virtual void read(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80002000;
+        // IRQ controller
+        switch (addr - 0x80002000) {
+        case 0x00:
+            *(uint32_t *)buf = isr_mask_;
+            break;
+        case 0x04:
+            *(uint32_t *)buf = isr_pending_;
+            break;
+        case 0x10:
+            *((IsrEntryType **)buf) = isr_table_;
+            break;
+        case 0x28:
+            *(uint32_t *)buf = irq_lock_;
+            break;
+        case 0x2c:
+            *(uint32_t *)buf = irq_cause_idx_;
+            break;
+        default:
+            break;
+        }
+    }
+
+    virtual void raise_interrupt(int idx) {
+        if (!isr_table_ || irq_lock_) {
+            return;
+        }
+        if (isr_table_[idx].func && ((isr_mask_ & (0x1 << idx)) == 0)) {
+            isr_pending_ |= (1 << idx);
+            isr_handler isr = (isr_handler)isr_table_[idx].func;
+            irq_cause_idx_ = (uint32_t)idx;
+            isr((void *)isr_table_[idx].arg);
+        }
+    }
+
+private:
+    typedef void (*isr_handler)(void *arg);
+
+    struct IsrEntryType {
+        uint64_t arg;
+        uint64_t func;
+    } *isr_table_;
+    uint32_t irq_lock_;
+    uint32_t isr_mask_;
+    uint32_t isr_pending_;
+    uint32_t irq_cause_idx_;
+};
+
diff --git a/arch/msvc/lib/pnp.cpp b/arch/msvc/lib/pnp.cpp
new file mode 100644
index 0000000..2b1bd00
--- /dev/null
+++ b/arch/msvc/lib/pnp.cpp
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "pnp.h"
+
+#define VENDOR_GNSSSENSOR        0x00F1
+
+#define GNSSSENSOR_EMPTY         0x5577     /// Dummy device
+#define GNSSSENSOR_BOOTROM       0x0071     /// Boot ROM Device ID
+#define GNSSSENSOR_FWIMAGE       0x0072     /// FW ROM image Device ID
+#define GNSSSENSOR_SRAM          0x0073     /// Internal SRAM block Device ID
+#define GNSSSENSOR_PNP           0x0074     /// Configuration Registers Module Device ID provided by gnsslib
+#define GNSSSENSOR_SPI_FLASH     0x0075     /// SD-card controller Device ID provided by gnsslib
+#define GNSSSENSOR_GPIO          0x0076     /// General purpose IOs Device ID provided by gnsslib
+#define GNSSSENSOR_RF_CONTROL    0x0077     /// RF front-end controller Device ID provided by gnsslib
+#define GNSSSENSOR_ENGINE        0x0078     /// GNSS Engine Device ID provided by gnsslib
+#define GNSSSENSOR_ENGINE_STUB   0x0068     /// GNSS Engine stub
+#define GNSSSENSOR_FSE_V2        0x0079     /// Fast Search Engines Device ID provided by gnsslib
+#define GNSSSENSOR_UART          0x007a     /// rs-232 UART Device ID
+#define GNSSSENSOR_ACCELEROMETER 0x007b     /// Accelerometer Device ID provided by gnsslib
+#define GNSSSENSOR_GYROSCOPE     0x007c     /// Gyroscope Device ID provided by gnsslib
+#define GNSSSENSOR_IRQCTRL       0x007d     /// Interrupt controller
+#define GNSSSENSOR_ETHMAC        0x007f
+#define GNSSSENSOR_DSU           0x0080
+#define GNSSSENSOR_GPTIMERS      0x0081
+
+
+#define TECH_INFERRED       0
+#define TECH_VIRTEX6        36
+#define TECH_KINTEX7        49
+
+#define ADDR_NASTI_SLAVE_FWIMAGE    0x00100000
+#define ADDR_NASTI_SLAVE_SRAM       0x10000000
+#define ADDR_NASTI_SLAVE_GPIO       0x80000000
+#define ADDR_NASTI_SLAVE_UART1      0x80001000
+#define ADDR_NASTI_SLAVE_IRQCTRL    0x80002000
+#define ADDR_NASTI_SLAVE_GNSSENGINE 0x80003000
+#define ADDR_NASTI_SLAVE_RFCTRL     0x80004000
+#define ADDR_NASTI_SLAVE_GPTIMERS   0x80005000
+#define ADDR_NASTI_SLAVE_FSEGPS     0x8000a000
+#define ADDR_NASTI_SLAVE_ETHMAC     0x80040000
+#define ADDR_NASTI_SLAVE_PNP        0xfffff000
+
+
+PNP::PNP() {
+        map_.hwid = 0x20151217LL;
+        map_.rsrv1 =  0;
+        map_.idt = 0;
+
+        int idx = 0;
+        map_.slaves[idx].xmask = 0xffffe000;
+        map_.slaves[idx].xaddr = 0;
+        map_.slaves[idx].did = GNSSSENSOR_BOOTROM;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffc0000;
+        map_.slaves[idx].xaddr = 0x00100000;
+        map_.slaves[idx].did = GNSSSENSOR_FWIMAGE;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfff80000;
+        map_.slaves[idx].xaddr = 0x10000000;
+        map_.slaves[idx].did = GNSSSENSOR_SRAM;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_GPIO;
+        map_.slaves[idx].did = GNSSSENSOR_GPIO;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_UART1;
+        map_.slaves[idx].did = GNSSSENSOR_UART;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_IRQCTRL;
+        map_.slaves[idx].did = GNSSSENSOR_IRQCTRL;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_GNSSENGINE;
+        map_.slaves[idx].did = GNSSSENSOR_ENGINE_STUB;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_GPTIMERS;
+        map_.slaves[idx].did = GNSSSENSOR_GPTIMERS;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_RFCTRL;
+        map_.slaves[idx].did = GNSSSENSOR_RF_CONTROL;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+
+#ifdef ENABLE_FSE
+        idx++;
+        map_.slaves[idx].xmask = 0xfffff000;
+        map_.slaves[idx].xaddr = ADDR_NASTI_SLAVE_FSEGPS;
+        map_.slaves[idx].did = GNSSSENSOR_FSE_V2;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+#endif
+
+#ifdef ENABLE_MAC
+        idx++;
+        map_.slaves[idx].xmask = 0xfffc0000;
+        map_.slaves[idx].xaddr = 0x80040000;
+        map_.slaves[idx].did = GNSSSENSOR_ETHMAC;
+        map_.slaves[idx].vid = VENDOR_GNSSSENSOR;
+        map_.slaves[idx].size = PNP_CONFIG_DEFAULT_BYTES;
+#endif
+
+        map_.tech =  ((idx + 1) << 8) | (TECH_VIRTEX6);
+}
\ No newline at end of file
diff --git a/arch/msvc/lib/pnp.h b/arch/msvc/lib/pnp.h
new file mode 100644
index 0000000..e452658
--- /dev/null
+++ b/arch/msvc/lib/pnp.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "imapdev.h"
+#include <memory>
+
+class PNP : public IMappedDevice {
+public:
+    PNP();
+
+    virtual bool isAddrValid(uint64_t addr) {
+        return (addr >= 0x0FFFFF000ull && addr < 0x100000000ull);
+    }
+    virtual void write(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0xFFFFF000;
+        memcpy(reinterpret_cast<char *>(&map_) + off, buf, size);
+    }
+    virtual void read(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0xFFFFF000;
+        memcpy(buf, reinterpret_cast<char *>(&map_) + off, size);
+    }
+
+
+private:
+    static const int PNP_CONFIG_DEFAULT_BYTES = 16;
+
+    typedef struct PnpConfigType {
+        uint32_t xmask;
+        uint32_t xaddr;
+        uint16_t did;
+        uint16_t vid;
+        uint8_t size;
+        uint8_t rsrv[3];
+    } PnpConfigType;
+
+    typedef struct pnp_map {
+        volatile uint32_t hwid;         /// Read only HW ID
+        volatile uint32_t fwid;         /// Read/Write Firmware ID
+        volatile uint32_t tech;         /// Read only technology index
+        volatile uint32_t rsrv1;        /// 
+        volatile uint64_t idt;          /// 
+        volatile uint64_t malloc_addr;  /// debuggind memalloc pointer
+        volatile uint64_t malloc_size;  /// debugging memalloc size
+        volatile uint64_t fwdbg1;       /// FW debug register
+        volatile uint64_t rsrv[2];
+        PnpConfigType slaves[64];
+    } pnp_map;
+    pnp_map map_;
+};
+
diff --git a/arch/msvc/lib/uart.h b/arch/msvc/lib/uart.h
new file mode 100644
index 0000000..f061090
--- /dev/null
+++ b/arch/msvc/lib/uart.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "imapdev.h"
+
+class Uart : public IMappedDevice {
+public:
+    Uart() {
+        rx_cnt_ = 0;
+        pwr_ = buf_;
+        prd_ = buf_;
+    }
+
+    virtual bool isAddrValid(uint64_t addr) {
+        return (addr >= 0x80001000 && addr < 0x80002000);
+    }
+    virtual void write(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80001000;
+        switch (off>>2) {
+        case 0x04:
+            std::cout << (char)buf[0];
+            break;
+        default:;
+        }
+
+    }
+    virtual void read(uint64_t addr, uint8_t *buf, int size) {
+        uint64_t off = addr - 0x80001000;
+        uint32_t tmp = 0;
+        switch (off>>2) {
+        case 0x0:
+            if (rx_cnt_ == 0) {
+                tmp |= UART_STATUS_RX_EMPTY;
+            }
+            *(uint32_t *)buf = tmp;
+            break;
+        case 0x04:
+            buf[0] = *prd_;
+            if (rx_cnt_) {
+                rx_cnt_--;
+                if ((++prd_) >= &buf_[FIFO_SIZE]) {
+                    prd_ = buf_;
+                }
+            }
+            break;
+        default:;
+        }
+    }
+
+    void putRx(char s) {
+        *pwr_ = *(pwr_+FIFO_SIZE) = s;
+        if ((++pwr_) >= &buf_[FIFO_SIZE]) {
+            pwr_ = buf_;
+        }
+        rx_cnt_++;
+    }
+
+private:
+    static const uint32_t UART_STATUS_TX_FULL     = 0x00000001;
+    static const uint32_t UART_STATUS_TX_EMPTY    = 0x00000002;
+    static const uint32_t UART_STATUS_RX_FULL     = 0x00000010;
+    static const uint32_t UART_STATUS_RX_EMPTY    = 0x00000020;
+    static const uint32_t UART_STATUS_ERR_PARITY  = 0x00000100;
+    static const uint32_t UART_STATUS_ERR_STOPBIT = 0x00000200;
+
+
+    static const int FIFO_SIZE = 64;
+    char buf_[2*FIFO_SIZE];
+    char *prd_, *pwr_;
+    int rx_cnt_;
+};
+
diff --git a/arch/msvc/lib/utils.cpp b/arch/msvc/lib/utils.cpp
new file mode 100644
index 0000000..8e8cbfd
--- /dev/null
+++ b/arch/msvc/lib/utils.cpp
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fstream>
+#include <iostream>
+#include "zephyr_threads.h"
+#include "irqctrl.h"
+#include "uart.h"
+#include "gptimers.h"
+#include "pnp.h"
+
+extern IrqController irqctrl;
+extern Uart uart0;
+extern GPTimers tmr0;
+extern PNP pnp;
+extern volatile bool wasPreemtiveSwitch;
+extern int current_idx;
+extern std::vector<ThreadDataType> vecThreads;
+
+extern "C" int LIBH_uart_output(int v) {
+    std::cout << (char)v;
+    return 0;
+}
+
+DWORD WINAPI thread_wrapper(LPVOID param) {
+    unsigned idx = ((unsigned )param);
+    //printf_s("<thread_wrapper> Event[%d] waiting\n", idx);
+    WaitForSingleObject(vecThreads[idx].hEvent, INFINITE);
+    ResetEvent(vecThreads[idx].hEvent);
+    //printf_s("<thread_wrapper> Event[%d] received\n", idx);
+    vecThreads[idx].func(vecThreads[idx].entry,
+                         vecThreads[idx].args[0],
+                         vecThreads[idx].args[1],
+                         vecThreads[idx].args[2]
+                         );
+    printf_s("<%s> End of thread[%d]!!\n", __FUNCTION__, idx);
+    return 0;
+}
+
+extern "C" int LIBH_create_thread(char *pStackMem,
+                              unsigned stackSize, 
+                              int priority, 
+                              unsigned options) {
+    //unsigned long * ctx = (unsigned long *)(pStackMem + stackSize);
+    tcs_simple *ctx = (tcs_simple *)pStackMem;
+    ThreadDataType data;
+    data.idx = (int)vecThreads.size();
+    data.stack_offset = (uint64_t)pStackMem;
+
+    data.func = (_thread_entry_asm)ctx->regs[REG_RA];
+    data.entry = (_thread_entry_t)ctx->regs[REG_A0];
+    data.args[0] = (_thread_arg_t)ctx->regs[REG_A1];
+    data.args[1] = (_thread_arg_t)ctx->regs[REG_A2];
+    data.args[2] = (_thread_arg_t)ctx->regs[REG_A3];
+    data.priority = priority;
+    data.options = options;
+    data.preemptive = false;
+    unsigned this_idx = (unsigned)vecThreads.size();
+
+    data.hEvent = CreateEvent(  NULL,               // default security attributes
+                                TRUE,               // manual-reset event
+                                FALSE,              // initial state is nonsignaled
+                                NULL          // object name
+                                ); 
+
+    data.hThread = CreateThread(NULL,
+                            0,
+                            thread_wrapper,
+                            (LPVOID)this_idx,
+                            CREATE_SUSPENDED,
+                            NULL
+                            );
+
+    vecThreads.push_back(data);
+    ResumeThread(data.hThread);
+    return 0;
+}
+
+int LIBH_get_thread_by_context(uint64_t ctx) {
+    ThreadDataType * ret = NULL;
+    for (unsigned i = 0; i < vecThreads.size(); i++) {
+        if (vecThreads[i].stack_offset == ctx) {
+            return (int)i;
+        }
+    }
+    return -1;
+}
+
+extern "C" void LIBH_swap(uint64_t stack) {
+    int next_idx = LIBH_get_thread_by_context(stack);
+
+    if (next_idx == current_idx) {
+        // Find preemptive halted thread:
+        for (unsigned i = 0; i < vecThreads.size(); i++) {
+            if (vecThreads[i].preemptive) {
+                next_idx = (int)i;
+                break;
+            }
+        }
+    }
+
+    if (next_idx != current_idx) {
+        int tmp_idx = current_idx;
+        current_idx = next_idx;
+        if (vecThreads[next_idx].preemptive) {
+            vecThreads[next_idx].preemptive = false;
+            ResumeThread(vecThreads[next_idx].hThread);
+        } else {
+            SetEvent(vecThreads[next_idx].hEvent);
+        }
+        vecThreads[tmp_idx].preemptive = false;
+        WaitForSingleObject(vecThreads[tmp_idx].hEvent, INFINITE);
+        ResetEvent(vecThreads[tmp_idx].hEvent);
+    } else {
+     
+    }
+}
+
+extern "C" void LIBH_swap_preemptive(uint64_t ctx_addr) {
+    int next_idx = LIBH_get_thread_by_context(ctx_addr);
+    vecThreads[current_idx].preemptive = true;
+    if (next_idx != -1) {
+        tcs_simple *ctx = (tcs_simple *)vecThreads[next_idx].stack_offset;
+        current_idx = next_idx;
+        if (vecThreads[next_idx].preemptive) {
+            ResumeThread(vecThreads[next_idx].hThread);
+        } else {
+            SetEvent(vecThreads[next_idx].hEvent);
+        }
+    }
+    wasPreemtiveSwitch = true;
+}
+
+
+extern "C" void LIBH_write(uint64_t addr, uint8_t *buf, int size) {
+    if (addr >= 0x80000000 && addr < 0x80001000) {
+        // GPIO
+    } else if (uart0.isAddrValid(addr)) {
+        uart0.write(addr, buf, size);
+    } else if (irqctrl.isAddrValid(addr)) {
+        irqctrl.write(addr, buf, size);
+    } else if (pnp.isAddrValid(addr)) {
+        pnp.write(addr, buf, size);
+    } else if (tmr0.isAddrValid(addr)) {
+        tmr0.write(addr, buf, size);
+    } else {
+        std::cout << "Unmapped access\n";
+    }
+}
+
+extern "C" void LIBH_read(uint64_t addr, uint8_t *buf, int size) {
+    if (addr >= 0x80000000 && addr < 0x80001000) {
+        // GPIO
+    } else if (uart0.isAddrValid(addr)) {
+        uart0.read(addr, buf, size);
+    } else if (irqctrl.isAddrValid(addr)) {
+        irqctrl.read(addr, buf, size);
+    } else if (pnp.isAddrValid(addr)) {
+        pnp.read(addr, buf, size);
+    } else if (tmr0.isAddrValid(addr)) {
+        tmr0.read(addr, buf, size);
+    } else {
+        std::cout << "Unmapped access\n";
+    }
+}
diff --git a/arch/msvc/lib/zephyr_threads.h b/arch/msvc/lib/zephyr_threads.h
new file mode 100644
index 0000000..b0e674f
--- /dev/null
+++ b/arch/msvc/lib/zephyr_threads.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <vector>
+#include <inttypes.h>
+
+#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
+#include <windows.h>
+#include <process.h>
+
+typedef void *_thread_arg_t;
+typedef void (*_thread_entry_t)(_thread_arg_t arg1,
+							  _thread_arg_t arg2,
+							  _thread_arg_t arg3);
+
+typedef void (*_thread_entry_asm)(_thread_entry_t pEntry,
+					_thread_arg_t parameter1,
+					_thread_arg_t parameter2,
+					_thread_arg_t parameter3);
+
+struct ThreadDataType {
+    int idx;
+    uint64_t stack_offset;
+    _thread_entry_asm func;
+    _thread_entry_t entry;
+    _thread_arg_t args[3];
+    int priority;
+    unsigned options;
+    HANDLE hThread;
+    HANDLE hEvent;
+    bool preemptive;
+};
+
+struct tcs_simple {
+    void *link;
+    uint64_t flags;
+    uint32_t intlock;
+    uint32_t rsrv1;
+    uint64_t regs[32];
+};
+enum ERegs {REG_RA=0, REG_V0=15, REG_A0=17, REG_A1=18, REG_A2=19, REG_A3=20, REG_A4=21};
+
+
+extern "C" int LIBH_create_thread(char *pStackMem,
+                                unsigned stackSize, 
+                                int priority, 
+                                unsigned options);
+extern "C" void LIBH_swap(uint64_t stack);
diff --git a/arch/msvc/msvc13/libhost/exportmap.def b/arch/msvc/msvc13/libhost/exportmap.def
new file mode 100644
index 0000000..7d54963
--- /dev/null
+++ b/arch/msvc/msvc13/libhost/exportmap.def
@@ -0,0 +1,9 @@
+LIBRARY libhost
+EXPORTS
+	LIBH_create_dispatcher
+	LIBH_uart_output
+	LIBH_create_thread
+	LIBH_swap
+	LIBH_write
+	LIBH_read
+	LIBH_swap_preemptive
diff --git a/arch/msvc/msvc13/libhost/libhost.vcxproj b/arch/msvc/msvc13/libhost/libhost.vcxproj
new file mode 100644
index 0000000..4eb00f8
--- /dev/null
+++ b/arch/msvc/msvc13/libhost/libhost.vcxproj
@@ -0,0 +1,93 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\lib\gptimers.h" />
+    <ClInclude Include="..\..\lib\imapdev.h" />
+    <ClInclude Include="..\..\lib\irqctrl.h" />
+    <ClInclude Include="..\..\lib\pnp.h" />
+    <ClInclude Include="..\..\lib\uart.h" />
+    <ClInclude Include="..\..\lib\zephyr_threads.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\lib\dispatcher.cpp" />
+    <ClCompile Include="..\..\lib\pnp.cpp" />
+    <ClCompile Include="..\..\lib\utils.cpp" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{232D555C-96EC-43B5-891F-CC955F1402B9}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>libhost</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBHOST_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ModuleDefinitionFile>exportmap.def</ModuleDefinitionFile>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBHOST_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/arch/msvc/msvc13/libhost/libhost.vcxproj.filters b/arch/msvc/msvc13/libhost/libhost.vcxproj.filters
new file mode 100644
index 0000000..b79e885
--- /dev/null
+++ b/arch/msvc/msvc13/libhost/libhost.vcxproj.filters
@@ -0,0 +1,40 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\lib\imapdev.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\lib\irqctrl.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\lib\uart.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\lib\zephyr_threads.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\lib\pnp.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\lib\gptimers.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\lib\dispatcher.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\lib\utils.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\lib\pnp.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj b/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj
new file mode 100644
index 0000000..af5cdbe
--- /dev/null
+++ b/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj
@@ -0,0 +1,206 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{449AD2B1-18DB-4E79-A52E-F67F9926649C}</ProjectGuid>
+    <RootNamespace>nanokernel</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup />
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)../../../lib/libc/minimal/include;$(SolutionDir)../../../include;$(SolutionDir)../../../include/generated;$(SolutionDir)../../../kernel/nanokernel/include;$(SolutionDir)../../../arch/riscv64/include;$(SolutionDir)../../../arch/riscv64/soc/riscv_gnss;$(SolutionDir)../../../boards/riscv_gnss;$(SolutionDir)../core;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalOptions>/D"__RISCV64" /D"INLINE=" /D"inline=" /D"_ARCH64" %(AdditionalOptions)</AdditionalOptions>
+      <PreprocessorDefinitions>CONFIG_RISCV64;CONFIG_PRINTK;CONFIG_STDOUT_CONSOLE;CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=60000000;CONFIG_SYS_CLOCK_TICKS_PER_SEC=100;CONFIG_NANO_TIMERS;CONFIG_MAIN_STACK_SIZE=16384;CONFIG_ISR_STACK_SIZE=256;CONFIG_KERNEL_EVENT_LOGGER_BUFFER_SIZE=16;CONFIG_NUM_IRQS=3;CONFIG_SW_ISR_TABLE_DYNAMIC;CONFIG_NANO_TIMEOUTS;CONFIG_NANOKERNEL;NANOKERNEL=1;CONFIG_KERNEL_EVENT_LOGGER;CONFIG_KERNEL_INIT_PRIORITY_DEFAULT=0x40;CONFIG_UART_CONSOLE;CONFIG_UART_CONSOLE_ON_DEV_NAME="UART_0";CONFIG_UART_INTERRUPT_DRIVEN;CONFIG_CONSOLE_HANDLER;CONFIG_CONSOLE_HANDLER_SHELL;CONFIG_CONSOLE_HANDLER_SHELL_STACKSIZE=2000;CONFIG_ERRNO;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>libhost.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(SolutionDir)$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
+      <EntryPointSymbol>BaseAddress_0x40000000</EntryPointSymbol>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\..\arch\riscv64\include\kernel_event_logger_arch.h" />
+    <ClInclude Include="..\..\..\..\arch\riscv64\include\nano_private.h" />
+    <ClInclude Include="..\..\..\..\include\arch\cpu.h" />
+    <ClInclude Include="..\..\..\..\include\arch\riscv64\arch.h" />
+    <ClInclude Include="..\..\..\..\include\atomic.h" />
+    <ClInclude Include="..\..\..\..\include\device.h" />
+    <ClInclude Include="..\..\..\..\include\drivers\console\uart_console.h" />
+    <ClInclude Include="..\..\..\..\include\drivers\rand32.h" />
+    <ClInclude Include="..\..\..\..\include\drivers\system_timer.h" />
+    <ClInclude Include="..\..\..\..\include\generated\offsets.h" />
+    <ClInclude Include="..\..\..\..\include\init.h" />
+    <ClInclude Include="..\..\..\..\include\irq.h" />
+    <ClInclude Include="..\..\..\..\include\kernel_version.h" />
+    <ClInclude Include="..\..\..\..\include\misc\byteorder.h" />
+    <ClInclude Include="..\..\..\..\include\misc\debug\debug_info.h" />
+    <ClInclude Include="..\..\..\..\include\misc\debug\gdb_server.h" />
+    <ClInclude Include="..\..\..\..\include\misc\debug\mem_safe.h" />
+    <ClInclude Include="..\..\..\..\include\misc\debug\object_tracing.h" />
+    <ClInclude Include="..\..\..\..\include\misc\debug\object_tracing_common.h" />
+    <ClInclude Include="..\..\..\..\include\misc\dlist.h" />
+    <ClInclude Include="..\..\..\..\include\misc\event_logger.h" />
+    <ClInclude Include="..\..\..\..\include\misc\kernel_event_logger.h" />
+    <ClInclude Include="..\..\..\..\include\misc\printk.h" />
+    <ClInclude Include="..\..\..\..\include\misc\reboot.h" />
+    <ClInclude Include="..\..\..\..\include\misc\ring_buffer.h" />
+    <ClInclude Include="..\..\..\..\include\misc\shell.h" />
+    <ClInclude Include="..\..\..\..\include\misc\slist.h" />
+    <ClInclude Include="..\..\..\..\include\misc\stack.h" />
+    <ClInclude Include="..\..\..\..\include\misc\sys_log.h" />
+    <ClInclude Include="..\..\..\..\include\misc\util.h" />
+    <ClInclude Include="..\..\..\..\include\misc\__assert.h" />
+    <ClInclude Include="..\..\..\..\include\nanokernel.h" />
+    <ClInclude Include="..\..\..\..\include\sections.h" />
+    <ClInclude Include="..\..\..\..\include\section_tags.h" />
+    <ClInclude Include="..\..\..\..\include\sys_clock.h" />
+    <ClInclude Include="..\..\..\..\include\toolchain.h" />
+    <ClInclude Include="..\..\..\..\include\toolchain\common.h" />
+    <ClInclude Include="..\..\..\..\include\toolchain\cl.h" />
+    <ClInclude Include="..\..\..\..\include\uart.h" />
+    <ClInclude Include="..\..\..\..\include\zephyr.h" />
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\gen_offset.h" />
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\nano_internal.h" />
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\nano_offsets.h" />
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\timeout_q.h" />
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\wait_q.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\assert.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\null.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\restrict.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\size_t.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\ctype.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\errno.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\limits.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdbool.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stddef.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdint.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdio.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdlib.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\string.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\strings.h" />
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\sys\types.h" />
+    <ClInclude Include="..\..\..\..\samples\shell\src\dhry.h" />
+    <ClInclude Include="..\..\..\riscv64\include\memaccess.h" />
+    <ClInclude Include="..\..\..\riscv64\soc\riscv_gnss\soc.h" />
+    <ClInclude Include="..\..\..\riscv64\soc\riscv_gnss\soc_registers.h" />
+    <ClInclude Include="..\..\core\device_link.h" />
+    <ClInclude Include="..\..\core\version.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\cpu_idle.c" />
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\fatal.c" />
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\irq_manage.c" />
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\thread.c" />
+    <ClCompile Include="..\..\..\..\drivers\console\console_handler_shell.c" />
+    <ClCompile Include="..\..\..\..\drivers\console\uart_console.c" />
+    <ClCompile Include="..\..\..\..\drivers\random\rand32_timer.c" />
+    <ClCompile Include="..\..\..\..\drivers\random\rand32_timestamp.c" />
+    <ClCompile Include="..\..\..\..\drivers\serial\uart_gnss.c" />
+    <ClCompile Include="..\..\..\..\drivers\timer\riscv_systimer.c" />
+    <ClCompile Include="..\..\..\..\drivers\timer\sys_clock_init.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\atomic_c.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\compiler_stack_protect.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\device.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\errno.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\event_logger.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\idle.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\int_latency_bench.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\kernel_event_logger.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_context.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_fiber.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_fifo.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_init.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_lifo.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sema.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sleep.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_stack.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sys_clock.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_timer.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_work.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\ring_buffer.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\timeout_q.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\version.c" />
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\wait_q.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\atoi.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\strtol.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\strtoul.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\fprintf.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\prf.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\sprintf.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\stdout_console.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\string.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\strncasecmp.c" />
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\strstr.c" />
+    <ClCompile Include="..\..\..\..\misc\printk.c" />
+    <ClCompile Include="..\..\..\..\samples\shell\src\dhry_1.c" />
+    <ClCompile Include="..\..\..\..\samples\shell\src\dhry_2.c" />
+    <ClCompile Include="..\..\..\..\samples\shell\src\main.c" />
+    <ClCompile Include="..\..\..\riscv64\core\gptimers.c" />
+    <ClCompile Include="..\..\..\riscv64\core\memaccess.c" />
+    <ClCompile Include="..\..\..\riscv64\soc\riscv_gnss\soc.c" />
+    <ClCompile Include="..\..\core\entry_point.c" />
+    <ClCompile Include="..\..\core\func_alias\compiler_stack_protect_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_fiber_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_fifo_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_lifo_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_sema_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_sleep_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_stack_alias.c" />
+    <ClCompile Include="..\..\core\func_alias\nano_timer_alias.c" />
+    <ClCompile Include="..\..\core\swap.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj.filters b/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj.filters
new file mode 100644
index 0000000..4b37b1c
--- /dev/null
+++ b/arch/msvc/msvc13/nanokernel/nanokernel.vcxproj.filters
@@ -0,0 +1,511 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="zephyr">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="zephyr\include">
+      <UniqueIdentifier>{c7ada7d3-8aeb-4b92-a892-ea3d30c1c192}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib">
+      <UniqueIdentifier>{809e7d87-09eb-4fd2-b88d-f331b8b89565}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc">
+      <UniqueIdentifier>{ca016d9f-6e95-4bed-984c-1947fdd251ea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal">
+      <UniqueIdentifier>{8c139816-0660-4a89-be5d-5731d7217620}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\include">
+      <UniqueIdentifier>{56ff872c-a49e-46c5-a942-cf909d5b8121}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\source">
+      <UniqueIdentifier>{d1443e73-7ec8-4977-8271-8527748cb91a}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\include\bits">
+      <UniqueIdentifier>{a963877a-d74c-4342-b26a-5ce596ae1008}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\include\sys">
+      <UniqueIdentifier>{fd975d1f-23a9-4866-ae07-dce7bd02fa8c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\source\stdlib">
+      <UniqueIdentifier>{04d14cbd-1285-4f5b-8851-3ea3d392992b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\source\stdout">
+      <UniqueIdentifier>{170f52bc-2510-40e8-904f-b25712e031f0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\lib\libc\minimal\source\string">
+      <UniqueIdentifier>{cb182e73-0c53-407e-8d93-6e8bc9294a1d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\misc">
+      <UniqueIdentifier>{c23e49bd-d8df-4867-9f58-0899de46b232}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\toolchain">
+      <UniqueIdentifier>{9aa4e565-3d86-4442-9c4b-e60813a09d5c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\arch">
+      <UniqueIdentifier>{c611c85a-2191-43ff-a580-b835628856a5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\arch\riscv64">
+      <UniqueIdentifier>{853cc0a9-6ed6-448e-a2e3-8070bd759754}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\kernel">
+      <UniqueIdentifier>{80ceb020-5750-44a6-86fb-945b0f813554}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\kernel\nanokernel">
+      <UniqueIdentifier>{b0449487-c067-4ae7-8668-51b219544c95}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\kernel\nanokernel\include">
+      <UniqueIdentifier>{6d53ba02-1dce-42bc-b4ed-9ea4f3704599}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch">
+      <UniqueIdentifier>{f973febf-5366-41e4-accb-67af5021dd62}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\riscv64">
+      <UniqueIdentifier>{fb1680ea-0bd9-45ab-9729-698247c3f42f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\riscv64\include">
+      <UniqueIdentifier>{afc9c1ee-efd2-4fbe-9514-f26032e439a5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\riscv64\core">
+      <UniqueIdentifier>{126b7d8c-c5c3-4bbb-850a-33e0ebbaa3df}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\drivers">
+      <UniqueIdentifier>{e4efcdae-559b-4e69-bf45-91e3494b6c47}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\drivers">
+      <UniqueIdentifier>{3bc83724-085d-4279-a515-6e410c5032b4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\drivers\timer">
+      <UniqueIdentifier>{091e359e-3bbd-4277-9b09-3b175933d600}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\generated">
+      <UniqueIdentifier>{defd420d-3296-46f2-918a-fbb38f1c80d3}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\drivers\console">
+      <UniqueIdentifier>{432e2021-2ada-4df8-8f43-e6af1b31c4ea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\drivers\console">
+      <UniqueIdentifier>{77732768-6b5c-4ba2-b63b-c93109f99337}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\riscv64\soc">
+      <UniqueIdentifier>{97ce9e2b-5c7b-4ac9-8f34-6d30d0b659f7}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\samples">
+      <UniqueIdentifier>{11229955-18f1-4d5a-9e12-4d377c86638d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\samples\shell">
+      <UniqueIdentifier>{4ccde392-55d5-4054-8163-d202a48ac0a4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\drivers\serial">
+      <UniqueIdentifier>{c80d6967-8769-4939-8e7b-7a299de9fbad}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\misc">
+      <UniqueIdentifier>{113c62ee-5932-4ad0-ac5d-49da1b5a6b5b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\msvc">
+      <UniqueIdentifier>{fea6f8e8-787d-43be-8a62-36fcf5c4c8c4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\include\misc\debug">
+      <UniqueIdentifier>{1fa2cabf-44f6-4bc0-a8da-26198575afcb}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\drivers\random">
+      <UniqueIdentifier>{082fcd7c-3a67-4024-97fb-01f283a8b0d2}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\msvc\core">
+      <UniqueIdentifier>{d3fa9d0a-a630-42f3-b5c7-2c634e770e9d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\riscv64\soc\riscv_gnss">
+      <UniqueIdentifier>{636db04e-f185-4b21-931c-37346bb6032f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="zephyr\arch\msvc\core\func_alias">
+      <UniqueIdentifier>{e88abf78-addc-4f9f-a78d-d3cf1c5f66a8}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\null.h">
+      <Filter>zephyr\lib\libc\minimal\include\bits</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\restrict.h">
+      <Filter>zephyr\lib\libc\minimal\include\bits</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\bits\size_t.h">
+      <Filter>zephyr\lib\libc\minimal\include\bits</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\sys\types.h">
+      <Filter>zephyr\lib\libc\minimal\include\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\ctype.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\errno.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\limits.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdbool.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stddef.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdint.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdio.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\stdlib.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\string.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\strings.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\section_tags.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\sections.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\toolchain.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\toolchain\common.h">
+      <Filter>zephyr\include\toolchain</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\toolchain\cl.h">
+      <Filter>zephyr\include\toolchain</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\kernel_version.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\sys_clock.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\nanokernel.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\arch\cpu.h">
+      <Filter>zephyr\include\arch</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\arch\riscv64\arch.h">
+      <Filter>zephyr\include\arch\riscv64</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\gen_offset.h">
+      <Filter>zephyr\kernel\nanokernel\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\nano_internal.h">
+      <Filter>zephyr\kernel\nanokernel\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\nano_offsets.h">
+      <Filter>zephyr\kernel\nanokernel\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\timeout_q.h">
+      <Filter>zephyr\kernel\nanokernel\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\kernel\nanokernel\include\wait_q.h">
+      <Filter>zephyr\kernel\nanokernel\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\arch\riscv64\include\nano_private.h">
+      <Filter>zephyr\arch\riscv64\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\drivers\rand32.h">
+      <Filter>zephyr\include\drivers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\drivers\system_timer.h">
+      <Filter>zephyr\include\drivers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\device.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\init.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\irq.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\generated\offsets.h">
+      <Filter>zephyr\include\generated</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\arch\riscv64\include\kernel_event_logger_arch.h">
+      <Filter>zephyr\arch\riscv64\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\atomic.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\uart.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\drivers\console\uart_console.h">
+      <Filter>zephyr\include\drivers\console</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\zephyr.h">
+      <Filter>zephyr\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\__assert.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\byteorder.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\dlist.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\event_logger.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\kernel_event_logger.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\printk.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\reboot.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\ring_buffer.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\shell.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\slist.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\stack.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\sys_log.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\util.h">
+      <Filter>zephyr\include\misc</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\debug\debug_info.h">
+      <Filter>zephyr\include\misc\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\debug\gdb_server.h">
+      <Filter>zephyr\include\misc\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\debug\mem_safe.h">
+      <Filter>zephyr\include\misc\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\debug\object_tracing.h">
+      <Filter>zephyr\include\misc\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\include\misc\debug\object_tracing_common.h">
+      <Filter>zephyr\include\misc\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\riscv64\soc\riscv_gnss\soc.h">
+      <Filter>zephyr\arch\riscv64\soc\riscv_gnss</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\riscv64\soc\riscv_gnss\soc_registers.h">
+      <Filter>zephyr\arch\riscv64\soc\riscv_gnss</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\riscv64\include\memaccess.h">
+      <Filter>zephyr\arch\riscv64\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\samples\shell\src\dhry.h">
+      <Filter>zephyr\samples\shell</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\core\device_link.h">
+      <Filter>zephyr\arch\msvc\core</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\core\version.h">
+      <Filter>zephyr\arch\msvc\core</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\lib\libc\minimal\include\assert.h">
+      <Filter>zephyr\lib\libc\minimal\include</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\atoi.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdlib</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\strtol.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdlib</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdlib\strtoul.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdlib</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\fprintf.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdout</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\prf.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdout</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\sprintf.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdout</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\stdout\stdout_console.c">
+      <Filter>zephyr\lib\libc\minimal\source\stdout</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\string.c">
+      <Filter>zephyr\lib\libc\minimal\source\string</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\strncasecmp.c">
+      <Filter>zephyr\lib\libc\minimal\source\string</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\misc\printk.c">
+      <Filter>zephyr\misc</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\ring_buffer.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\version.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_fifo.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_lifo.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sema.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_context.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\thread.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\fatal.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_fiber.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\timer\riscv_systimer.c">
+      <Filter>zephyr\drivers\timer</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\cpu_idle.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sys_clock.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_stack.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_timer.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_sleep.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\compiler_stack_protect.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\device.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\event_logger.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\idle.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\int_latency_bench.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\kernel_event_logger.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_init.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\console\uart_console.c">
+      <Filter>zephyr\drivers\console</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\console\console_handler_shell.c">
+      <Filter>zephyr\drivers\console</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\serial\uart_gnss.c">
+      <Filter>zephyr\drivers\serial</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\timer\sys_clock_init.c">
+      <Filter>zephyr\drivers\timer</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\arch\riscv64\core\irq_manage.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\samples\shell\src\main.c">
+      <Filter>zephyr\samples\shell</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\random\rand32_timer.c">
+      <Filter>zephyr\drivers\random</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\drivers\random\rand32_timestamp.c">
+      <Filter>zephyr\drivers\random</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\riscv64\core\gptimers.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\errno.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\entry_point.c">
+      <Filter>zephyr\arch\msvc\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\swap.c">
+      <Filter>zephyr\arch\msvc\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\riscv64\soc\riscv_gnss\soc.c">
+      <Filter>zephyr\arch\riscv64\soc\riscv_gnss</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\riscv64\core\memaccess.c">
+      <Filter>zephyr\arch\riscv64\core</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\samples\shell\src\dhry_1.c">
+      <Filter>zephyr\samples\shell</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\samples\shell\src\dhry_2.c">
+      <Filter>zephyr\samples\shell</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\nano_work.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\timeout_q.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\wait_q.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\compiler_stack_protect_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_fiber_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_fifo_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_lifo_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_sema_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_sleep_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_stack_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\core\func_alias\nano_timer_alias.c">
+      <Filter>zephyr\arch\msvc\core\func_alias</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\lib\libc\minimal\source\string\strstr.c">
+      <Filter>zephyr\lib\libc\minimal\source\string</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\kernel\nanokernel\atomic_c.c">
+      <Filter>zephyr\kernel\nanokernel</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/arch/msvc/msvc13/zephyr.sln b/arch/msvc/msvc13/zephyr.sln
new file mode 100644
index 0000000..28605fc
--- /dev/null
+++ b/arch/msvc/msvc13/zephyr.sln
@@ -0,0 +1,31 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 2013
+VisualStudioVersion = 12.0.21005.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nanokernel", "nanokernel\nanokernel.vcxproj", "{449AD2B1-18DB-4E79-A52E-F67F9926649C}"
+	ProjectSection(ProjectDependencies) = postProject
+		{232D555C-96EC-43B5-891F-CC955F1402B9} = {232D555C-96EC-43B5-891F-CC955F1402B9}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libhost", "libhost\libhost.vcxproj", "{232D555C-96EC-43B5-891F-CC955F1402B9}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{449AD2B1-18DB-4E79-A52E-F67F9926649C}.Debug|x64.ActiveCfg = Debug|x64
+		{449AD2B1-18DB-4E79-A52E-F67F9926649C}.Debug|x64.Build.0 = Debug|x64
+		{449AD2B1-18DB-4E79-A52E-F67F9926649C}.Release|x64.ActiveCfg = Release|x64
+		{449AD2B1-18DB-4E79-A52E-F67F9926649C}.Release|x64.Build.0 = Release|x64
+		{232D555C-96EC-43B5-891F-CC955F1402B9}.Debug|x64.ActiveCfg = Debug|x64
+		{232D555C-96EC-43B5-891F-CC955F1402B9}.Debug|x64.Build.0 = Debug|x64
+		{232D555C-96EC-43B5-891F-CC955F1402B9}.Release|x64.ActiveCfg = Release|x64
+		{232D555C-96EC-43B5-891F-CC955F1402B9}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/arch/riscv64/Kbuild b/arch/riscv64/Kbuild
new file mode 100644
index 0000000..29c89e7
--- /dev/null
+++ b/arch/riscv64/Kbuild
@@ -0,0 +1,3 @@
+obj-y += core/
+obj-$(CONFIG_GDB_SERVER) += debug/
+obj-y += soc/$(SOC_PATH)/
diff --git a/arch/riscv64/Kconfig b/arch/riscv64/Kconfig
new file mode 100644
index 0000000..82bc143
--- /dev/null
+++ b/arch/riscv64/Kconfig
@@ -0,0 +1,54 @@
+# ARC EM4 options
+
+#
+# Copyright (c) 2014 Wind River Systems, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+choice
+	prompt "RISC-V SoC Selection"
+	depends on RISCV64
+
+	source "arch/riscv64/soc/*/Kconfig.soc"
+endchoice
+
+
+menu "RISC-V Options"
+	depends on RISCV64
+
+config ARCH
+	default "riscv64"
+
+config ARCH_DEFCONFIG
+	string
+	default "arch/riscv64/defconfig"
+
+config SRAM_SIZE
+	int "SRAM Size in kB"
+	help
+	This option specifies the size of the SRAM in kB.  It is normally set
+	by the platform's defconfig file and the user should generally avoid
+	modifying it via the menu configuration.
+
+config SRAM_BASE_ADDRESS
+	hex "SRAM Base Address"
+	help
+	This option specifies the base address of the SRAM on the platform.  It
+	is normally set by the platform's defconfig file and the user should
+	generally avoid modifying it via the menu configuration.
+
+
+source "arch/riscv64/soc/*/Kconfig"
+
+endmenu
diff --git a/arch/riscv64/Makefile b/arch/riscv64/Makefile
new file mode 100644
index 0000000..a316d60
--- /dev/null
+++ b/arch/riscv64/Makefile
@@ -0,0 +1,8 @@
+cflags-y += $(call cc-option,-ffunction-sections,) $(call cc-option,-fdata-sections,)
+cflags-$(CONFIG_LTO) = $(call cc-option,-flto,)
+
+include $(srctree)/arch/$(ARCH)/soc/$(SOC_PATH)/Makefile
+
+KBUILD_CFLAGS += $(cflags-y)
+KBUILD_CFLAGS += -Wno-unused-function
+KBUILD_CXXFLAGS += $(cflags-y)
diff --git a/arch/riscv64/_howto_build_riscv b/arch/riscv64/_howto_build_riscv
new file mode 100644
index 0000000..a9c0eb3
--- /dev/null
+++ b/arch/riscv64/_howto_build_riscv
@@ -0,0 +1,3 @@
+cd samples/shell
+export ZEPHYR_BASE=/home/teeshina/riscv/riscv_vhdl/zephyr/
+make ARCH=riscv64 CROSS_COMPILE=/home/teeshina/riscv/gnu-toolchain-rv64ima/bin/riscv64-unknown-elf- BOARD=riscv_gnss 2>&1 | tee _err.log
diff --git a/arch/riscv64/core/Makefile b/arch/riscv64/core/Makefile
new file mode 100644
index 0000000..3b4bb09
--- /dev/null
+++ b/arch/riscv64/core/Makefile
@@ -0,0 +1,6 @@
+ccflags-y += -I$(srctree)/kernel/nanokernel/include
+ccflags-y +=-I$(srctree)/arch/$(ARCH)/include
+ccflags-y += -I$(srctree)/kernel/microkernel/include
+
+obj-y += cpu_idle.o fatal.o gptimers.o \
+	irq_manage.o swap.o thread.o memaccess.o
diff --git a/arch/riscv64/core/cpu_idle.c b/arch/riscv64/core/cpu_idle.c
new file mode 100644
index 0000000..ef07c81
--- /dev/null
+++ b/arch/riscv64/core/cpu_idle.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief CPU power management
+ *
+ * CPU power management routines.
+ */
+
+#include <nano_private.h>
+#include <toolchain.h>
+#include <sections.h>
+#include <arch/cpu.h>
+
+/*
+ * @brief Put the CPU in low-power mode
+ *
+ * This function always exits with interrupts unlocked.
+ *
+ * void nanCpuIdle(void)
+ */
+
+void nano_cpu_idle(void) {
+	while(0) {}
+}
+/*
+ * @brief Put the CPU in low-power mode, entered with IRQs locked
+ *
+ * This function exits with interrupts restored to <key>.
+ *
+ * void nano_cpu_atomic_idle(unsigned int key)
+ */
+void nano_cpu_atomic_idle(unsigned int key) {
+	while (0) {}
+}
\ No newline at end of file
diff --git a/arch/riscv64/core/fatal.c b/arch/riscv64/core/fatal.c
new file mode 100644
index 0000000..82fdf39
--- /dev/null
+++ b/arch/riscv64/core/fatal.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013-2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief Nanokernel fatal error handler
+ *
+ * This module provides the _NanoFatalErrorHandler() routine.
+ */
+
+#include <toolchain.h>
+#include <sections.h>
+
+#include <nanokernel.h>
+#include <nano_private.h>
+#include <misc/printk.h>
+
+const NANO_ESF _default_esf = {
+	0xdeaddead, /* placeholder */
+};
+
+
+/**
+ *
+ * @brief Nanokernel fatal error handler
+ *
+ * This routine is called when a fatal error condition is detected by either
+ * hardware or software.
+ *
+ * The caller is expected to always provide a usable ESF.  In the event that the
+ * fatal error does not have a hardware generated ESF, the caller should either
+ * create its own or use a pointer to the global default ESF <_default_esf>.
+ *
+ * @param reason the reason that the handler was called
+ * @param pEsf pointer to the exception stack frame
+ *
+ * @return This function does not return.
+ */
+FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
+					  const NANO_ESF *pEsf)
+{
+
+#ifdef CONFIG_PRINTK
+       printk("***** Unhandled interrupt vector %d occurred! \n", -1);
+#endif
+    while (1) {}
+}
\ No newline at end of file
diff --git a/arch/riscv64/core/gptimers.c b/arch/riscv64/core/gptimers.c
new file mode 100644
index 0000000..91da2b4
--- /dev/null
+++ b/arch/riscv64/core/gptimers.c
@@ -0,0 +1,9 @@
+#include <toolchain.h>
+#include <sections.h>
+#include <nano_private.h>
+
+//
+uint32_t _do_read_cpu_timestamp32(void) {
+    return 500;//READ32();
+}
+
diff --git a/arch/riscv64/core/irq_manage.c b/arch/riscv64/core/irq_manage.c
new file mode 100644
index 0000000..7eba4be
--- /dev/null
+++ b/arch/riscv64/core/irq_manage.c
@@ -0,0 +1,111 @@
+#include <nanokernel.h>
+#include <nano_private.h>
+#include <misc/__assert.h>
+#include <board.h>
+
+IsrEntryType isr_table[CONFIG_NUM_IRQS];
+IsrEntryType isr_demux_table[CONFIG_NUM_IRQS];
+
+extern void _IsrExit(void);
+
+void _IsrWrapper(void *arg) {
+    uint32_t isr_idx = READ32(&__IRQCTRL->irq_cause_idx);
+    ((NANO_EOI_GET_FUNC)isr_demux_table[isr_idx].handler)(arg);
+    _IsrExit();
+}
+
+unsigned int _arch_irq_lock(void) {
+    unsigned int ret = READ32(&__IRQCTRL->irq_lock);
+    WRITE32(&__IRQCTRL->irq_lock, 1);
+    return ret;
+}
+
+void _arch_irq_unlock(unsigned int key) {
+    WRITE32(&__IRQCTRL->irq_lock, key);
+}
+
+unsigned int _arch_irq_lock_state() {
+    return READ32(&__IRQCTRL->irq_lock);
+}
+
+/**
+ *
+ * @brief Enable an interrupt line
+ *
+ * Clear possible pending interrupts on the line, and enable the interrupt
+ * line. After this call, the CPU will receive interrupts for the specified
+ * <irq>.
+ *
+ * @return N/A
+ */
+void _arch_irq_enable(unsigned int irq)
+{
+	/* before enabling interrupts, ensure that interrupt is cleared */
+    uint32_t bit = READ32(&__IRQCTRL->irq_mask);
+    bit &= ~(1u << irq);
+    WRITE32(&__IRQCTRL->irq_clear, 1u << irq);
+    WRITE32(&__IRQCTRL->irq_mask, bit);
+}
+
+/**
+ *
+ * @brief Disable an interrupt line
+ *
+ * Disable an interrupt line. After this call, the CPU will stop receiving
+ * interrupts for the specified <irq>.
+ *
+ * @return N/A
+ */
+void _arch_irq_disable(unsigned int irq)
+{
+    uint32_t bit = READ32(&__IRQCTRL->irq_mask);
+    bit |= (1u << irq);
+    WRITE32(&__IRQCTRL->irq_mask, bit);
+}
+
+/*
+ * @internal
+ *
+ * @brief Replace an interrupt handler by another
+ *
+ * An interrupt's ISR can be replaced at runtime.
+ *
+ * @return N/A
+ */
+
+void _irq_handler_set(
+	unsigned int irq,
+	void (*new)(void *arg),
+	void *arg
+)
+{
+	int key = irq_lock();
+
+	__ASSERT(irq < CONFIG_NUM_IRQS, "IRQ number too high");
+	isr_table[irq].handler = (uint64_t)_IsrWrapper;
+	isr_table[irq].arg = (uint64_t)arg;
+    isr_demux_table[irq].handler = (uint64_t)new;
+
+	irq_unlock(key);
+}
+
+/*
+ * @brief Connect an ISR to an interrupt line
+ *
+ * @a isr is connected to interrupt line @a irq, a number greater than or equal
+ * 16. No prior ISR can have been connected on @a irq interrupt line since the
+ * system booted.
+ *
+ * This routine will hang if another ISR was connected for interrupt line @a irq
+ * and ASSERT_ON is enabled; if ASSERT_ON is disabled, it will fail silently.
+ *
+ * @return the interrupt line number
+ */
+int _arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,
+			     void (*routine)(void *arg), void *parameter,
+			     uint32_t flags)
+{
+	ARG_UNUSED(flags);
+	_irq_handler_set(irq, routine, parameter);
+	return irq;
+}
diff --git a/arch/riscv64/core/memaccess.c b/arch/riscv64/core/memaccess.c
new file mode 100644
index 0000000..ad1f324
--- /dev/null
+++ b/arch/riscv64/core/memaccess.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <bits/size_t.h>
+
+#ifdef _WIN32
+extern void LIBH_write(uint64_t addr, uint8_t *buf, int size);
+extern void LIBH_read(uint64_t addr, uint8_t *buf, int size);
+#endif
+
+uint16_t READ16(volatile uint16_t *addr)
+{
+#ifdef _WIN32
+    uint16_t ret;
+    LIBH_read((uint64_t)((size_t)addr), (uint8_t *)&ret, 2);
+    return ret;
+#else
+    return *addr;
+#endif
+}
+
+uint32_t READ32(volatile uint32_t *addr)
+{
+#ifdef _WIN32
+    uint32_t ret;
+    LIBH_read((uint64_t)((size_t)addr), (uint8_t *)&ret, 4);
+    return ret;
+#else
+    return *addr;
+#endif
+}
+
+uint64_t READ64(volatile uint64_t *addr)
+{
+#ifdef _WIN32
+    uint64_t ret;
+    LIBH_read((uint64_t)((size_t)addr), (uint8_t *)&ret, 8);
+    return ret;
+#else
+    return *addr;
+#endif
+}
+
+void WRITE32(volatile uint32_t *addr, uint32_t val)
+{
+#ifdef _WIN32
+    LIBH_write((uint64_t)((size_t)addr), (uint8_t *)&val, 4);
+#else
+    *addr = val;
+#endif
+}
+
+void WRITE64(volatile uint64_t *addr, uint64_t val)
+{
+#ifdef _WIN32
+    LIBH_write((uint64_t)((size_t)addr), (uint8_t *)&val, 8);
+#else
+    *addr = val;
+#endif
+}
diff --git a/arch/riscv64/core/offsets/offsets.c b/arch/riscv64/core/offsets/offsets.c
new file mode 100644
index 0000000..3b453bb
--- /dev/null
+++ b/arch/riscv64/core/offsets/offsets.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief RISC-V nano kernel structure member offset definition file
+ *
+ * This module is responsible for the generation of the absolute symbols whose
+ * value represents the member offsets for various RISC-V nanokernel
+ * structures.
+ *
+ * All of the absolute symbols defined by this module will be present in the
+ * final microkernel or nanokernel ELF image (due to the linker's reference to
+ * the _OffsetAbsSyms symbol).
+ *
+ * INTERNAL
+ * It is NOT necessary to define the offset for every member of a structure.
+ * Typically, only those members that are accessed by assembly language routines
+ * are defined; however, it doesn't hurt to define all fields for the sake of
+ * completeness.
+ */
+
+#include <gen_offset.h>
+#include <nano_private.h>
+#include <nano_offsets.h>
+
+GEN_OFFSET_SYM(tTCS, return_value);
+
+/* size of the struct tcs structure sans save area for floating point regs */
+GEN_ABSOLUTE_SYM(__tTCS_NOFLOAT_SIZEOF, sizeof(tTCS));
+
+GEN_ABS_SYM_END
diff --git a/arch/riscv64/core/swap.S b/arch/riscv64/core/swap.S
new file mode 100644
index 0000000..dd226c0
--- /dev/null
+++ b/arch/riscv64/core/swap.S
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2014-2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define _ASMLANGUAGE
+
+#include "swap_macros.h"
+
+/**
+ *
+ * @brief Initiate a cooperative context switch
+ *
+ * The _Swap() routine is invoked by various nanokernel services to effect
+ * a cooperative context switch.  Prior to invoking _Swap(), the caller
+ * disables interrupts via nanoCpuIntLock() and the return 'key' is passed as a
+ * parameter to _Swap(). The key is in fact the value stored in the register
+ * operand of a CLRI instruction.
+ *
+ * It stores the intlock key parameter into current->intlock_key.
+
+ * Given that _Swap() is called to effect a cooperative context switch,
+ * the caller-saved integer registers are saved on the stack by the function
+ * call preamble to _Swap(). This creates a custom stack frame that will be
+ * popped when returning from _Swap(), but is not suitable for handling a return
+ * from an exception. Thus, the fact that the thread is pending because of a
+ * cooperative call to _Swap() has to be recorded via the _CAUSE_COOP code in
+ * the relinquish_cause of the thread's tTCS. The _IrqExit()/_FirqExit() code
+ * will take care of doing the right thing to restore the thread status.
+ *
+ * When _Swap() is invoked, we know the decision to perform a context switch or
+ * not has already been taken and a context switch must happen.
+ *
+ * @return may contain a return value setup by a call to fiberRtnValueSet()
+ *
+ * C function prototype:
+ *
+ * unsigned int _Swap (unsigned int key);
+ *
+ */
+
+.section ".text"
+.globl __start
+__start:
+	jal _Cstart;
+
+.section ".text"
+.globl _Swap
+_Swap:
+	/* interrupts are locked, interrupt key is in r0 */
+	_save_context(tp)
+        sd ra,COOP_REG_MEPC(tp)
+	la s0, _nanokernel
+	ld s1,tNANO_CURRENT_OFFSET(s0)	# s1 = _nanokernel.current
+	sw x0,TCS_INTLOCK_OFFSET(s1)    # _nanokernel.current->intlock = 0
+
+	ld s1,tNANO_FIBER_OFFSET(s0)
+	bnez s1, _swap_to_a_fiber
+_swap_to_the_task:
+	ld s2,tNANO_TASK_OFFSET(s0)     # current = nanokernel.task
+	sd s2,tNANO_CURRENT_OFFSET(s0)	# nanokernel.current = current
+        lw a0,TCS_INTLOCK_OFFSET(s2)
+        jal _arch_irq_unlock            # _arch_irq_unlock(current->intlock)
+	addi tp,s2,TCS_COOP_REGS_OFFSET	# tp = &current->coopRegs
+	_restore_context(tp)
+        ld t6,COOP_REG_MEPC(tp)
+	jalr x0,t6
+
+_swap_to_a_fiber:
+	ld s2,tNANO_FIBER_OFFSET(s0)
+	ld s3,TCS_LINK_OFFSET(s2)	# s3 = nanokernel.fiber->link
+	sd s3,tNANO_FIBER_OFFSET(s0)	# nanokernel.fiber = s3
+	sd s2,tNANO_CURRENT_OFFSET(s0)	# nanokernel.current = current
+        lw a0,TCS_INTLOCK_OFFSET(s2)
+        jal _arch_irq_unlock            # _arch_irq_unlock(current->intlock)
+	addi tp,s2,TCS_COOP_REGS_OFFSET	# tp = &current->coopRegs
+	_restore_context(tp)
+	ret
+
+.globl _IsrExit
+_IsrExit:
+        addi sp,sp,40
+        sd s0,0(sp)
+        sd s2,8(sp)
+        sd s3,16(sp)
+
+	la s0, _nanokernel
+	ld s1,tNANO_CURRENT_OFFSET(s0)	# s1 = _nanokernel.current
+	ld s2,TCS_FLAGS_OFFSET(s1)	# s2 = _nanokernel.current->flags
+        # Only Task may be preemptedly switched (Fibers can not)
+        andi s2,s2,1
+	beqz s2,_IsrExit_ending         # ((s2 & TASK) != TASK) goto _IsrExit_ending
+	ld s2,tNANO_FIBER_OFFSET(s0)
+	beqz s2,_IsrExit_ending         # if(_nanokernel.current->fiber==0) goto _IsrExit_ending
+        
+        sd ra,24(sp)
+        sd a0,32(sp)
+        jal _arch_irq_lock_state        # a0 = _arch_irq_lock_state()
+        sw a0,TCS_INTLOCK_OFFSET(s1)	# _nanokernel.current->intlock=_arch_irq_lock_state()
+	sd s2,tNANO_CURRENT_OFFSET(s0)	# nanokernel.current = current
+	ld s3,TCS_LINK_OFFSET(s2)	# s3 = nanokernel.fiber->link
+	sd s3,tNANO_FIBER_OFFSET(s0)	# nanokernel.fiber = s3
+
+        lw a0,TCS_INTLOCK_OFFSET(s2)
+        jal _arch_irq_unlock            # _arch_irq_unlock(current->intlock)
+
+        # Set 'tp' register pointing to new task registers array, so
+        # that ROM interrupt handler will restore full context on exit
+	addi tp,s2,TCS_COOP_REGS_OFFSET
+        ld a0,32(sp)
+        ld ra,24(sp)
+_IsrExit_ending:
+        ld s0,0(sp)
+        ld s2,8(sp)
+        ld s3,16(sp)
+        addi sp,sp,-40
+	ret
diff --git a/arch/riscv64/core/swap_macros.h b/arch/riscv64/core/swap_macros.h
new file mode 100644
index 0000000..10f0f2b
--- /dev/null
+++ b/arch/riscv64/core/swap_macros.h
@@ -0,0 +1,146 @@
+/* swap_macros.h - helper macros for context switch */
+
+/*
+ * Copyright (c) 2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SWAP_MACROS__H_
+#define _SWAP_MACROS__H_
+
+#define tNANO_FIBER_OFFSET   0
+#define tNANO_TASK_OFFSET    8
+#define tNANO_CURRENT_OFFSET 16
+
+#define TCS_LINK_OFFSET         0
+#define TCS_FLAGS_OFFSET        8
+#define TCS_INTLOCK_OFFSET      16
+#define TCS_COOP_REGS_OFFSET    24
+
+/**
+ * Saved by callee function registers:
+ *      s0..s11, sp, tp
+ */
+
+/** Return address */
+#define COOP_REG_RA         0//(0*sizeof(uint64_t))
+/** Saved registers */
+#define COOP_REG_S0         8//(1*sizeof(uint64_t))
+#define COOP_REG_S1         16//(2*sizeof(uint64_t))
+#define COOP_REG_S2         24//(3*sizeof(uint64_t))
+#define COOP_REG_S3         32//(4*sizeof(uint64_t))
+#define COOP_REG_S4         40//(5*sizeof(uint64_t))
+#define COOP_REG_S5         48//(6*sizeof(uint64_t))
+#define COOP_REG_S6         56//(7*sizeof(uint64_t))
+#define COOP_REG_S7         64//(8*sizeof(uint64_t))
+#define COOP_REG_S8         72//(9*sizeof(uint64_t))
+#define COOP_REG_S9         80//(10*sizeof(uint64_t))
+#define COOP_REG_S10        88//(11*sizeof(uint64_t))
+#define COOP_REG_S11        96//(12*sizeof(uint64_t))
+/** Stack pointer */
+#define COOP_REG_SP         104//(13*sizeof(uint64_t))
+/** Thread pointer */
+#define COOP_REG_TP         112//(14*sizeof(uint64_t))
+#define COOP_REG_MEPC       COOP_REG_TP//(14*sizeof(uint64_t))
+/** Return values */
+#define COOP_REG_V0         120//(15*sizeof(uint64_t))
+#define COOP_REG_V1         128//(16*sizeof(uint64_t))
+/** Function Arguments */
+#define COOP_REG_A0         136//(17*sizeof(uint64_t))
+#define COOP_REG_A1         144//(18*sizeof(uint64_t))
+#define COOP_REG_A2         152//(19*sizeof(uint64_t))
+#define COOP_REG_A3         160//(20*sizeof(uint64_t))
+#define COOP_REG_A4         168//(21*sizeof(uint64_t))
+#define COOP_REG_A5         176//(22*sizeof(uint64_t))
+#define COOP_REG_A6         184//(23*sizeof(uint64_t))
+#define COOP_REG_A7         192//(24*sizeof(uint64_t))
+/** Temporary registers */
+#define COOP_REG_T0         200//(25*sizeof(uint64_t))
+#define COOP_REG_T1         208//(26*sizeof(uint64_t))
+#define COOP_REG_T2         216//(27*sizeof(uint64_t))
+#define COOP_REG_T3         224//(28*sizeof(uint64_t))
+#define COOP_REG_T4         232//(29*sizeof(uint64_t))
+/** Global pointer */
+#define COOP_REG_GP         240//(30*sizeof(uint64_t))
+
+#define COOP_REGS_TOTAL     32
+#define COOP_STACKFRAME_SIZE (COOP_REGS_TOTAL*sizeof(uint64_t))
+
+#define _save_context(TO) \
+  sd ra, COOP_REG_RA(TO); \
+  sd s0, COOP_REG_S0(TO); \
+  sd s1, COOP_REG_S1(TO); \
+  sd s2, COOP_REG_S2(TO); \
+  sd s3, COOP_REG_S3(TO); \
+  sd s4, COOP_REG_S4(TO); \
+  sd s5, COOP_REG_S5(TO); \
+  sd s6, COOP_REG_S6(TO); \
+  sd s7, COOP_REG_S7(TO); \
+  sd s8, COOP_REG_S8(TO); \
+  sd s9, COOP_REG_S9(TO); \
+  sd s10, COOP_REG_S10(TO); \
+  sd s11, COOP_REG_S11(TO); \
+  sd sp, COOP_REG_SP(TO); \
+  sd x16, COOP_REG_V0(TO); \
+  sd x17, COOP_REG_V1(TO); \
+  sd a0, COOP_REG_A0(TO); \
+  sd a1, COOP_REG_A1(TO); \
+  sd a2, COOP_REG_A2(TO); \
+  sd a3, COOP_REG_A3(TO); \
+  sd a4, COOP_REG_A4(TO); \
+  sd a5, COOP_REG_A5(TO); \
+  sd a6, COOP_REG_A6(TO); \
+  sd a7, COOP_REG_A7(TO); \
+  sd t0, COOP_REG_T0(TO); \
+  sd t1, COOP_REG_T1(TO); \
+  sd t2, COOP_REG_T2(TO); \
+  sd t3, COOP_REG_T3(TO); \
+  sd t4, COOP_REG_T4(TO); \
+  sd gp, COOP_REG_GP(TO);
+
+
+#define _restore_context(FROM) \
+  ld ra, COOP_REG_RA(FROM); \
+  ld s0, COOP_REG_S0(FROM); \
+  ld s1, COOP_REG_S1(FROM); \
+  ld s2, COOP_REG_S2(FROM); \
+  ld s3, COOP_REG_S3(FROM); \
+  ld s4, COOP_REG_S4(FROM); \
+  ld s5, COOP_REG_S5(FROM); \
+  ld s6, COOP_REG_S6(FROM); \
+  ld s7, COOP_REG_S7(FROM); \
+  ld s8, COOP_REG_S8(FROM); \
+  ld s9, COOP_REG_S9(FROM); \
+  ld s10, COOP_REG_S10(FROM); \
+  ld s11, COOP_REG_S11(FROM); \
+  ld sp, COOP_REG_SP(FROM); \
+  ld x16, COOP_REG_V0(FROM); \
+  ld x17, COOP_REG_V1(FROM); \
+  ld a0, COOP_REG_A0(FROM); \
+  ld a1, COOP_REG_A1(FROM); \
+  ld a2, COOP_REG_A2(FROM); \
+  ld a3, COOP_REG_A3(FROM); \
+  ld a4, COOP_REG_A4(FROM); \
+  ld a5, COOP_REG_A5(FROM); \
+  ld a6, COOP_REG_A6(FROM); \
+  ld a7, COOP_REG_A7(FROM); \
+  ld t0, COOP_REG_T0(FROM); \
+  ld t1, COOP_REG_T1(FROM); \
+  ld t2, COOP_REG_T2(FROM); \
+  ld t3, COOP_REG_T3(FROM); \
+  ld t4, COOP_REG_T4(FROM); \
+  ld gp, COOP_REG_GP(FROM);
+
+
+#endif /*  _SWAP_MACROS__H_ */
diff --git a/arch/riscv64/core/thread.c b/arch/riscv64/core/thread.c
new file mode 100644
index 0000000..86eba16
--- /dev/null
+++ b/arch/riscv64/core/thread.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2010-2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief Nanokernel thread support primitives
+ *
+ * This module provides core nanokernel fiber related primitives for the IA-32
+ * processor architecture.
+ */
+
+#ifdef CONFIG_MICROKERNEL
+#include <microkernel.h>
+#include <micro_private_types.h>
+#endif /* CONFIG_MICROKERNEL */
+#ifdef CONFIG_INIT_STACKS
+#include <string.h>
+#endif /* CONFIG_INIT_STACKS */
+
+#include <toolchain.h>
+#include <sections.h>
+#include <nano_private.h>
+#include <wait_q.h>
+
+#ifdef _WIN32
+extern int LIBH_create_thread(char *pStackMem,
+                              unsigned stackSize, 
+                              int priority, 
+                              unsigned options);
+#endif
+
+/* the one and only nanokernel control structure */
+
+tNANO _nanokernel = {0};
+
+/**
+ *
+ * @brief Create a new kernel execution thread
+ *
+ * This function is utilized to create execution threads for both fiber
+ * threads and kernel tasks.
+ *
+ * The "thread control block" (TCS) is carved from the "end" of the specified
+ * thread stack memory.
+ *
+ * @param pStackmem the pointer to aligned stack memory
+ * @param stackSize the stack size in bytes
+ * @param pEntry thread entry point routine
+ * @param parameter1 first param to entry point
+ * @param parameter2 second param to entry point
+ * @param parameter3 third param to entry point
+ * @param priority  thread priority
+ * @param options thread options: USE_FP, USE_SSE
+ *
+ *
+ * @return opaque pointer to initialized TCS structure
+ */
+void _new_thread(char *pStackMem, unsigned stackSize,
+		 void *uk_task_ptr, _thread_entry_t pEntry,
+		 _thread_arg_t parameter1, _thread_arg_t parameter2, _thread_arg_t parameter3,
+		 int priority, unsigned options)
+{
+	/* ptr to the new task's tcs */
+	struct tcs *tcs = (struct tcs *)pStackMem;
+	unsigned long *pInitialCtx;
+
+#ifdef CONFIG_INIT_STACKS
+	memset(pStackMem, 0xaa, stackSize);
+#endif
+
+	/* carve the thread entry struct from the "base" of the stack */
+
+	pInitialCtx =
+		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
+
+	/*
+	 * Create an initial context on the stack expected by the _Swap()
+	 * primitive.
+	 * Given that both task and fibers execute at privilege 0, the
+	 * setup for both threads are equivalent.
+	 */
+
+
+	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
+	tcs->prio = priority;
+	if (priority == -1) {
+		tcs->flags = PREEMPTIBLE | TASK;
+	} else {
+		tcs->flags = FIBER;
+    }
+    tcs->intlock = 0;
+
+#ifdef CONFIG_THREAD_CUSTOM_DATA
+	/* Initialize custom data field (value is opaque to kernel) */
+	tcs->custom_data = NULL;
+#endif
+
+#if defined(CONFIG_THREAD_MONITOR)
+	/*
+	 * In debug mode tcs->entry give direct access to the thread entry
+	 * and the corresponding parameters.
+	 */
+	tcs->entry = (struct __thread_entry *)(pInitCtx);
+#endif /* CONFIG_THREAD_MONITOR */
+#ifdef CONFIG_MICROKERNEL
+	tcs->uk_task_ptr = uk_task_ptr;
+#else
+	ARG_UNUSED(uk_task_ptr);
+#endif
+
+	_nano_timeout_tcs_init(tcs);
+
+	/*
+	 * @note Stack area for 'callee' saved registers: s0-s11, sp,tp can be
+	 * left uninitialized, since _thread_entry() doesn't care about the values
+	 * of these registers when it begins execution
+	 */
+    pInitialCtx -= COOP_STACKFRAME_SIZE;
+
+    *(uint64_t *)((uint8_t *)(tcs) + COOP_REG_SP) = (unsigned long)pInitialCtx;
+	PRINTK("\nInitial context SP = 0x%x\n", (unsigned long)pInitialCtx);
+    tcs->coopReg[COOP_REG_RA/sizeof(uint64_t)] = (uint64_t)_thread_entry;
+    tcs->coopReg[COOP_REG_MEPC/sizeof(uint64_t)] = (uint64_t)_thread_entry;
+    tcs->coopReg[COOP_REG_A0/sizeof(uint64_t)] = (uint64_t)pEntry;
+    tcs->coopReg[COOP_REG_A1/sizeof(uint64_t)] = (uint64_t)parameter1;
+    tcs->coopReg[COOP_REG_A2/sizeof(uint64_t)] = (uint64_t)parameter2;
+    tcs->coopReg[COOP_REG_A3/sizeof(uint64_t)] = (uint64_t)parameter3;
+    tcs->coopReg[COOP_REG_SP/sizeof(uint64_t)] = 
+        (uint64_t)(STACK_ROUND_DOWN(pStackMem + stackSize)) - COOP_REGS_TOTAL;
+#ifdef _WIN32
+    LIBH_create_thread(pStackMem, stackSize, priority, options);
+#endif
+}
diff --git a/arch/riscv64/defconfig b/arch/riscv64/defconfig
new file mode 100644
index 0000000..9e9e21d
--- /dev/null
+++ b/arch/riscv64/defconfig
@@ -0,0 +1,9 @@
+CONFIG_RISCV64=y
+CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=60000000
+CONFIG_RISCV_SYSTIMER=y
+CONFIG_CONSOLE=y
+CONFIG_SERIAL=y
+CONFIG_UART_RISCV_GNSS=y
+CONFIG_UART_CONSOLE=y
+CONFIG_CONSOLE_HAS_DRIVER=y
+CONFIG_PRINTK=y
diff --git a/arch/riscv64/include/kernel_event_logger_arch.h b/arch/riscv64/include/kernel_event_logger_arch.h
new file mode 100644
index 0000000..b6b8e67
--- /dev/null
+++ b/arch/riscv64/include/kernel_event_logger_arch.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief Kernel event logger support for ARM
+ */
+
+#ifndef __KERNEL_EVENT_LOGGER_ARCH_H__
+#define __KERNEL_EVENT_LOGGER_ARCH_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Get the identification of the current interrupt.
+ *
+ * This routine obtain the key of the interrupt that is currently processed
+ * if it is called from a ISR context.
+ *
+ * @return The key of the interrupt that is currently being processed.
+ */
+int _sys_current_irq_key_get(void)
+{
+	return 0;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __KERNEL_EVENT_LOGGER_ARCH_H__ */
diff --git a/arch/riscv64/include/memaccess.h b/arch/riscv64/include/memaccess.h
new file mode 100644
index 0000000..7daf9ac
--- /dev/null
+++ b/arch/riscv64/include/memaccess.h
@@ -0,0 +1,16 @@
+/**
+ * @file Access methods declaration to the memory mapped devices.
+ */
+
+#ifndef _RISCV_CORE_MEMACCESS_H_
+#define _RISCV_CORE_MEMACCESS_H_
+
+#include <stdint.h>
+
+extern uint16_t READ16(volatile uint16_t *addr);
+extern uint32_t READ32(volatile uint32_t *addr);
+extern uint64_t READ64(volatile uint64_t *addr);
+extern void WRITE32(volatile uint32_t *addr, uint32_t val);
+extern void WRITE64(volatile uint64_t *addr, uint64_t val);
+
+#endif  // _RISCV_CORE_MEMACCESS_H_
diff --git a/arch/riscv64/include/nano_private.h b/arch/riscv64/include/nano_private.h
new file mode 100644
index 0000000..5e3365a
--- /dev/null
+++ b/arch/riscv64/include/nano_private.h
@@ -0,0 +1,349 @@
+/*
+ * Copyright (c) 2013-2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief Private nanokernel definitions (RISC-V)
+ *
+ * This file contains private nanokernel structures definitions and various
+ * other definitions for the ARM Cortex-M3 processor architecture.
+ *
+ * This file is also included by assembly language files which must #define
+ * _ASMLANGUAGE before including this header file.  Note that nanokernel
+ * assembly source files obtains structure offset values via "absolute symbols"
+ * in the offsets.o module.
+ */
+
+#ifndef _NANO_PRIVATE_H
+#define _NANO_PRIVATE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <toolchain.h>
+#include <sections.h>
+#include <irq.h>
+#include <nanokernel.h>		   /* public nanokernel API */
+#include <../../../kernel/nanokernel/include/nano_internal.h>
+#include <stdint.h>
+#include <misc/dlist.h>
+
+#include <misc/util.h>
+#include "../core/swap_macros.h"
+
+#ifdef _DEBUG
+#include <misc/printk.h>
+#define PRINTK(...) printk(__VA_ARGS__)
+#else
+#define PRINTK(...)
+#endif /* DEBUG */
+
+
+/* increase to 16 bytes (or more?) to support SSE/SSE2 instructions? */
+
+/* stacks */
+
+#define STACK_ALIGN_SIZE 8
+
+#define STACK_ROUND_UP(x) ROUND_UP(x, STACK_ALIGN_SIZE)
+#define STACK_ROUND_DOWN(x) ROUND_DOWN(x, STACK_ALIGN_SIZE)
+
+/*
+ * Reason a thread has relinquished control: fibers can only be in the NONE
+ * or COOP state, tasks can be one in the four.
+ */
+#define _CAUSE_NONE 0
+#define _CAUSE_COOP 1
+#define _CAUSE_RIRQ 2
+#define _CAUSE_FIRQ 3
+
+
+/*
+ * Bitmask definitions for the struct tcs->flags bit field
+ *
+ * The USE_FP flag bit will be set whenever a thread uses any non-integer
+ * capability, whether it's just the x87 FPU capability, SSE instructions, or
+ * a combination of both. The USE_SSE flag bit will only be set if a thread
+ * uses SSE instructions.
+ *
+ * Note: Any change to the definitions USE_FP and USE_SSE must also be made to
+ * nanokernel/x86/arch.h.
+ */
+
+#define FIBER 0
+#define TASK 0x1	       /* 1 = task, 0 = fiber   */
+#define INT_ACTIVE 0x2     /* 1 = executing context is interrupt handler */
+#define EXC_ACTIVE 0x4     /* 1 = executing context is exception handler */
+#define USE_FP 0x10	       /* 1 = thread uses floating point unit */
+#define USE_SSE 0x20       /* 1 = thread uses SSEx instructions */
+#define PREEMPTIBLE 0x100  /* 1 = preemptible thread */
+#define ESSENTIAL 0x200    /* 1 = system thread that must not abort */
+#define NO_METRICS 0x400   /* 1 = _Swap() not to update task metrics */
+#define NO_METRICS_BIT_OFFSET 0xa /* Bit position of NO_METRICS */
+
+#define INT_OR_EXC_MASK (INT_ACTIVE | EXC_ACTIVE)
+
+
+/*
+ * The following structure defines the set of 'non-volatile' integer registers.
+ * These registers must be preserved by a called C function.  These are the
+ * only registers that need to be saved/restored when a cooperative context
+ * switch occurs.
+ *
+ *      x0      zero    Hard-wired zero             -
+ *      x1      ra      Return address              Caller
+ *      x2      s0/fp   Saved register/frame pointer Callee
+ *      x3-13   s1-11   Saved registers             Callee
+ *      x14     sp      Stack pointer               Callee
+ *      x15     tp      Thread pointer              Callee
+ *      x16-17  v0-1    Return values               Caller
+ *      x18-25  a0-7    Function arguments          Caller
+ *      x26-30  t0-4    Temporaries                 Caller
+ *      x31     gp      Global pointer              -
+ *      -------------
+ *      f0-15   fs0-15  FP saved registers          Callee
+ *      f16-17  fv0-1   FP return values            Caller
+ *      f18-25  fa0-7   FP arguments                Caller
+ *      f26-31  ft0-5   FP temporaries              Caller * 
+ */
+
+/*
+ * The following structure defines the set of 'volatile' integer registers.
+ * These registers need not be preserved by a called C function.  Given that
+ * they are not preserved across function calls, they must be save/restored
+ * (along with the s_coop_reg) when a preemptive context switch occurs.
+ */
+
+typedef struct s_preempReg {
+
+	/*
+	 * The volatile registers 'eax', 'ecx' and 'edx' area not included in
+	 *the
+	 * definition of 'tPreempReg' since the interrupt stubs
+	 *(_IntEnt/_IntExit)
+	 * and exception stubs (_ExcEnt/_ExcEnter) use the stack to save and
+	 * restore the values of these registers in order to support interrupt
+	 * nesting.  The stubs do _not_ copy the saved values from the stack
+	 *into
+	 * the TCS.
+	 *
+	 * unsigned long eax;
+	 * unsigned long ecx;
+	 * unsigned long edx;
+	 */
+     int empty;
+
+} tPreempReg;
+
+
+
+/*
+ * The thread control stucture definition.  It contains the
+ * various fields to manage a _single_ thread. The TCS will be aligned
+ * to the appropriate architecture specific boundary via the
+ * _new_thread() call.
+ */
+
+struct tcs {
+	/*
+	 * Link to next thread in singly-linked thread list (such as
+	 * prioritized list of runnable fibers, or list of fibers waiting on a
+	 * nanokernel FIFO).
+	 */
+	struct tcs *link;
+
+	/*
+	 * See the above flag definitions above for valid bit settings.  This
+	 * field must remain near the start of struct tcs, specifically
+	 * before any #ifdef'ed fields since the host tools currently use a
+	 * fixed
+	 * offset to read the 'flags' field.
+	 */
+	uint64_t flags;
+
+    /**
+     * interrupt key (irq_lock) when relinquishing control
+     */
+    uint32_t intlock;
+    uint32_t rsrv1;
+
+	/*
+	 * Storage space for integer registers.  These must also remain near
+	 * the start of struct tcs for the same reason mention for
+	 * 'flags'.
+	 */
+    uint64_t coopReg[COOP_REGS_TOTAL];     /* non-volatile integer register storage */
+	tPreempReg preempReg; /* volatile integer register storage */
+
+#if defined(CONFIG_THREAD_MONITOR)
+	struct tcs *next_thread; /* next item in list of ALL fiber+tasks */
+#endif
+#ifdef CONFIG_GDB_INFO
+	void *esfPtr; /* pointer to exception stack frame saved by */
+		      /* outermost exception wrapper */
+#endif		      /* CONFIG_GDB_INFO */
+    /*
+     * thread priority used to sort linked list
+     *         fiber priority, -1 for a task
+     */
+	int prio;
+
+#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
+	/*
+	 * Nested exception count to maintain setting of EXC_ACTIVE flag across
+	 * outermost exception.  EXC_ACTIVE is used by _Swap() lazy FP
+	 * save/restore and by debug tools.
+	 */
+	unsigned excNestCount; /* nested exception count */
+#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */
+
+#ifdef CONFIG_THREAD_CUSTOM_DATA
+	void *custom_data;     /* available for custom use */
+#endif
+
+#ifdef CONFIG_NANO_TIMEOUTS
+	struct _nano_timeout nano_timeout;
+#endif
+
+#ifdef CONFIG_ERRNO
+	int errno_var;
+#endif
+};
+
+/*
+ * The nanokernel structure definition.  It contains various fields to
+ * manage _all_ the threads in the nanokernel (system level).
+ */
+
+typedef struct s_NANO {
+	struct tcs *fiber;   /* singly linked list of runnable fibers */
+	struct tcs *task;    /* pointer to runnable task */
+	struct tcs *current; /* currently scheduled thread (fiber or task) */
+#if defined(CONFIG_THREAD_MONITOR)
+	struct tcs *threads; /* singly linked list of ALL fiber+tasks */
+#endif
+	unsigned nested;  /* nested interrupt count */
+	char *common_isp; /* interrupt stack pointer base */
+
+#ifdef CONFIG_ADVANCED_POWER_MANAGEMENT
+	int32_t idle; /* Number of ticks for kernel idling */
+#endif		      /* CONFIG_ADVANCED_POWER_MANAGEMENT */
+
+
+#ifdef CONFIG_FP_SHARING
+	/*
+	 * A 'current_sse' field does not exist in addition to the 'current_fp'
+	 * field since it's not possible to divide the IA-32 non-integer
+	 * registers into 2 distinct blocks owned by differing threads.  In
+	 * other words, given that the 'fxnsave/fxrstor' instructions
+	 * save/restore both the X87 FPU and XMM registers, it's not possible
+	 * for a thread to only "own" the XMM registers.
+	 */
+
+	struct tcs *current_fp; /* thread (fiber or task) that owns the FP regs */
+#endif			  /* CONFIG_FP_SHARING */
+#ifdef CONFIG_NANO_TIMEOUTS
+	sys_dlist_t timeout_q;
+	int32_t task_timeout;
+#endif
+} tNANO;
+
+/*
+ * There is only a single instance of the s_NANO structure, given that there
+ * is only a single nanokernel in the system: _nanokernel
+ */
+
+extern tNANO _nanokernel;
+
+/* INLINE function definitions */
+
+/**
+ *
+ * @brief Performs architecture-specific initialization
+ *
+ * This routine performs architecture-specific initialization of the nanokernel.
+ * Trivial stuff is done inline; more complex initialization is done via
+ * function calls.
+ *
+ * @return N/A
+ */
+static INLINE void nanoArchInit(void)
+{
+
+}
+
+/**
+ *
+ * @brief Set the return value for the specified fiber (inline)
+ *
+ * @param fiber pointer to fiber
+ * @param value value to set as return value
+ *
+ * The register used to store the return value from a function call invocation
+ * is set to <value>.  It is assumed that the specified <fiber> is pending, and
+ * thus the fibers context is stored in its TCS.
+ *
+ * @return N/A
+ */
+static INLINE void fiberRtnValueSet(struct tcs *fiber, void *value)
+{
+	fiber->coopReg[COOP_REG_A0/sizeof(uint64_t)] = (uint64_t)value;
+}
+
+/* definitions to support nanoCpuExcConnect() */
+
+#define _EXC_STUB_SIZE 0x14
+
+/* function prototypes */
+
+extern void nano_cpu_atomic_idle(unsigned int imask);
+
+extern void nanoCpuExcConnect(unsigned int vector,
+			      void (*routine)(NANO_ESF *pEsf));
+
+extern void _IntVecSet(unsigned int vector,
+		       void (*routine)(void *),
+		       unsigned int dpl);
+
+
+/*
+ * _IntLibInit() is called from the non-arch specific nanokernel function,
+ * _nano_init(). The IA-32 nanokernel does not require any special
+ * initialization of the interrupt subsystem. However, we still need to
+ * provide an _IntLibInit() of some sort to prevent build errors.
+ */
+static INLINE void _IntLibInit(void)
+{
+}
+
+int _stub_alloc(unsigned int *ep, unsigned int limit);
+void *_get_dynamic_stub(int stub_idx, void *base_ptr);
+uint8_t _stub_idx_from_vector(int vector);
+
+/* the _idt_base_address symbol is generated via a linker script */
+extern unsigned char _idt_base_address[];
+
+#include <stddef.h> /* For size_t */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#define _IS_IN_ISR() (_nanokernel.nested != 0)
+
+#endif /* _NANO_PRIVATE_H */
diff --git a/arch/riscv64/soc/riscv_gnss/Kbuild b/arch/riscv64/soc/riscv_gnss/Kbuild
new file mode 100644
index 0000000..52341f8
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/Kbuild
@@ -0,0 +1 @@
+obj-y += soc.o
diff --git a/arch/riscv64/soc/riscv_gnss/Kconfig.defconfig b/arch/riscv64/soc/riscv_gnss/Kconfig.defconfig
new file mode 100644
index 0000000..120157a
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/Kconfig.defconfig
@@ -0,0 +1,54 @@
+# Kconfig - Atmel SAM3 family processor configuration options
+
+#
+# Copyright (c) 2016 Intel Corporation.
+# Copyright (c) 2014-2015 Wind River Systems, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+if SOC_RISCV_GNSS
+
+config SOC
+	default riscv_gnss
+
+config NUM_IRQS
+	int
+	default 5
+
+config SYS_CLOCK_HW_CYCLES_PER_SEC
+	int
+	default 60000000
+
+#
+# SRAM address depends on the SoC generic parameters.
+#
+config SRAM_SIZE
+	default 512 if SOC_RISCV_GNSS
+
+config SRAM_BASE_ADDRESS
+	default 0x10000000
+
+config UART_RISCV_GNSS
+	def_bool y
+
+config UART_CONSOLE
+	def_bool y
+
+config CONSOLE_HANDLER_SHELL
+	def_bool y
+
+config CONSOLE_HAS_DRIVER
+	def_bool y
+
+endif # SOC_RISCV_GNSS
diff --git a/arch/riscv64/soc/riscv_gnss/Kconfig.soc b/arch/riscv64/soc/riscv_gnss/Kconfig.soc
new file mode 100644
index 0000000..84626cb
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/Kconfig.soc
@@ -0,0 +1,5 @@
+
+config SOC_RISCV_GNSS
+	bool "RISC-V SOC by Gnss Sensor Ltd"
+	help
+	Synthezable SoC based on open ISA RISC-V.
diff --git a/arch/riscv64/soc/riscv_gnss/Makefile b/arch/riscv64/soc/riscv_gnss/Makefile
new file mode 100644
index 0000000..bd58d54
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/Makefile
@@ -0,0 +1,6 @@
+
+arch-cflags += $(call cc-option,-mthumb -march=rv64ima -Wunused-function)
+
+KBUILD_AFLAGS += $(arch-cflags)
+KBUILD_CXXFLAGS += $(arch-cflags)
+KBUILD_CFLAGS += $(arch-cflags)
diff --git a/arch/riscv64/soc/riscv_gnss/linker.ld b/arch/riscv64/soc/riscv_gnss/linker.ld
new file mode 100644
index 0000000..202191c
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/linker.ld
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2014-2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * generate a symbol to mark the start of the device initialization objects for
+ * the specified level, then link all of those objects (sorted by priority);
+ * ensure the objects aren't discarded if there is no direct reference to them
+ */
+
+#define DEVICE_INIT_LEVEL(level)				\
+		__device_##level##_start = .;			\
+		KEEP(*(SORT(.init_##level[0-9])));		\
+		KEEP(*(SORT(.init_##level[1-9][0-9])));	\
+
+/*
+ * link in device initialization objects for all devices that are automatically
+ * initialized by the kernel; the objects are sorted in the order they will be
+ * initialized (i.e. ordered by level, sorted by priority within a level)
+ */
+
+#define	DEVICE_INIT_SECTIONS()			\
+		__device_init_start = .;		\
+		DEVICE_INIT_LEVEL(PRIMARY)		\
+		DEVICE_INIT_LEVEL(SECONDARY)	\
+		DEVICE_INIT_LEVEL(NANOKERNEL)	\
+		DEVICE_INIT_LEVEL(MICROKERNEL)	\
+		DEVICE_INIT_LEVEL(APPLICATION)	\
+		__device_init_end = .;
+
+
+/**
+ * @brief Common parts of the linker scripts for the Risc-V targets.
+ */
+
+SECTIONS
+{
+
+  /* text: test code section */
+  . = 0x10000000;
+  .text :
+  {
+    	*(.text)
+		*(".text.*")
+		*(.gnu.linkonce.t.*)
+  }
+
+  .devconfig :
+  {
+	__devconfig_start = .;
+	*(".devconfig.*")
+	KEEP(*(SORT_BY_NAME(".devconfig*")))
+	__devconfig_end = .;
+  }
+
+  .rodata :
+  {
+	*(.rodata)
+	*(".rodata.*")
+	*(.gnu.linkonce.r.*)
+  }
+
+  /* data segment */
+  .data : { *(.data) }
+
+  .initlevel :
+  {
+		DEVICE_INIT_SECTIONS()
+  }
+
+  .sdata : {
+    *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata*)
+    *(.sdata .sdata.* .gnu.linkonce.s.*)
+  }
+
+  /* bss segment */
+  .sbss : {
+    *(.sbss .sbss.* .gnu.linkonce.sb.*)
+    *(.scommon)
+  }
+  .bss : { *(.bss) }
+
+  /* thread-local data segment */
+  .tdata :
+  {
+    _tls_data = .;
+    *(.tdata)
+  }
+  .tbss :
+  {
+    *(.tbss)
+  }
+
+  /* End of uninitalized data segement */
+  _end = .;
+}
diff --git a/arch/riscv64/soc/riscv_gnss/soc.c b/arch/riscv64/soc/riscv_gnss/soc.c
new file mode 100644
index 0000000..349e06d
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/soc.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief System/hardware module for GNSS RISC-V family processor
+ *
+ * This module provides routines to initialize and support board-level hardware
+ * for the GNSS RISC-V family processor.
+ */
+
+#include <nanokernel.h>
+#include <device.h>
+#include <init.h>
+#include <soc.h>
+#include <misc/printk.h>
+
+extern IsrEntryType isr_table[CONFIG_NUM_IRQS];
+
+const char *const VENDOR_NAME = "GNSS Sensor Ltd.";
+
+const char *const EMPTY_ID_NAME = "Empty slot";
+
+const char *const UNKOWN_ID_NAME = "Unknown";
+
+static const char *const GNSS_SENSOR_DEVICE_NAMES[] = {
+    "GNSS Engine stub",         // 0x68
+    "Reserved",                 // 0x69
+    "Reserved",                 // 0x6a
+    "Reserved",                 // 0x6b
+    "Reserved",                 // 0x6c
+    "Reserved",                 // 0x6d
+    "Reserved",                 // 0x6e
+    "Reserved",                 // 0x6f
+    "Reserved",                 // 0x70
+    "Boot ROM",                 // 0x71
+    "FW Image ROM",             // 0x72
+    "Internal SRAM",            // 0x73
+    "Plug'n'Play support",      // 0x74
+    "SD Controller",            // 0x75
+    "Generic GPIO",             // 0x76
+    "RF front-end controller",  // 0x77
+    "GNSS Engine",              // 0x78
+    "GPS FSE",                  // 0x79
+    "Generic UART",             // 0x7a
+    "Accelerometer",            // 0x7b
+    "Gyroscope",                // 0x7c
+    "Interrupt Controller",     // 0x7d
+    "Reserved",                 // 0x7e
+    "Ethernet MAC",             // 0x7f
+    "Debug Support Unit (DSU)", // 0x80
+    "GP Timers"                 // 0x81
+};
+
+/**
+ * @brief Get technology name
+ */
+const char *const get_tech_name(uint32_t tech)
+{
+    switch (tech) {
+    case TECH_INFERRED: return "inferred";
+    case TECH_VIRTEX6: return "Virtex6";
+    case TECH_KINTEX7: return "Kintex7";
+    default:;
+    }
+    return "unknown";
+}
+
+/**
+ * @brief Get device Vendor name by its ID
+ */
+static const char *get_vendor_name(uint16_t vid)
+{
+    if (vid != VENDOR_GNSSSENSOR) {
+        return UNKOWN_ID_NAME;
+    }
+    return VENDOR_NAME;
+}
+
+/**
+ * @brief Get device Name by Vendor ID and Device ID
+ */
+static const char *get_device_name(uint16_t vid, uint16_t did)
+{
+    if (vid != VENDOR_GNSSSENSOR) {
+        return UNKOWN_ID_NAME;
+    }
+    if (did == GNSSSENSOR_EMPTY) {
+        return EMPTY_ID_NAME;
+    }
+    if (did < GNSSSENSOR_ENGINE_STUB || did > GNSSSENSOR_GPTIMERS) {
+        return UNKOWN_ID_NAME;
+    }
+    return GNSS_SENSOR_DEVICE_NAMES[did - GNSSSENSOR_ENGINE_STUB];
+}
+
+/**
+ * @brief Print Plug'n'Play information
+ *
+ * This function reads information from the PNP slave device that is mapped
+ * into hardcoded address __PNP (0xFFFFF000).
+ */
+void soc_print_pnp()
+{
+    uint32_t slaves_total, tech, hwid;
+    uint16_t vid, did;
+    adr_type xaddr, xmask, xsize;
+
+    tech = READ32(&__PNP->tech);
+    slaves_total = (tech >> 8) & 0xff;
+    printk("# RISC-V:  Rocket-Chip demonstration design\n");
+    hwid = READ32(&__PNP->hwid);
+    printk("# HW id:   0x%x\n", hwid);
+    hwid = READ32(&__PNP->fwid);
+    printk("# FW id:   0x%x\n", hwid);
+    printk("# Target technology: %s\n", get_tech_name(tech & 0xFF));
+
+    for (uint32_t i = 0; i < slaves_total; i++) {
+        vid = READ16(&__PNP->slaves[i].vid);
+        did = READ16(&__PNP->slaves[i].did);
+        xaddr = READ32(&__PNP->slaves[i].xaddr);
+        xmask = READ32(&__PNP->slaves[i].xmask);
+        xmask ^= 0xFFFFFFFF;
+        xsize = xmask + 1;
+
+        printk("# AXI4: slv%d: %s    %s\n", i, 
+            get_vendor_name(vid), get_device_name(vid, did));
+
+        printk("#    %x...%x, size = ",
+            (unsigned long)xaddr, (unsigned long)(xaddr + xmask));
+        if (xsize < 1024) {
+            printk("%d bytes\n", (int)xsize);
+        } else if (xsize < 1024*1024) {
+            printk("%d KB\n", (int)(xsize >> 10));
+        } else {
+            printk("%d MB\n", (int)(xsize >> 20));
+        }
+    }
+}
+
+/**
+ *
+ * @brief perform basic hardware initialization
+ *
+ * Hardware initialized:
+ * - interrupt unit
+ *
+ * RETURNS: N/A
+ */
+static int riscv_gnss_soc_init(struct device *arg)
+{
+	ARG_UNUSED(arg);
+    WRITE64(&__IRQCTRL->isr_table, (uint64_t)isr_table);
+    WRITE32(&__IRQCTRL->irq_lock, 0);
+	return 0;
+}
+
+/**
+ * @brief Check hardware target configuration is it inferred or not.
+ *
+ * inferred hardware target is used for RTL simulation of the whole SOC design.
+ */
+uint32_t soc_is_rtl_simulation()
+{
+    uint32_t tech = READ32(&__PNP->tech);
+    return (tech & 0xff) == TECH_INFERRED ? 1: 0;
+}
+
+SYS_INIT(riscv_gnss_soc_init, PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
+
diff --git a/arch/riscv64/soc/riscv_gnss/soc.h b/arch/riscv64/soc/riscv_gnss/soc.h
new file mode 100644
index 0000000..cba59aa
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/soc.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file SoC configuration macros for the GNSS Sensor Risc-V family processors.
+ */
+
+#ifndef _RISCV_SOC_GNSS_H_
+#define _RISCV_SOC_GNSS_H_
+
+#include <device.h>
+#include <misc/util.h>
+#include <drivers/rand32.h>
+#include <memaccess.h>
+
+#include "soc_registers.h"
+
+#define VENDOR_GNSSSENSOR        0x00F1
+
+#define GNSSSENSOR_EMPTY         0x5577     /// Dummy device
+#define GNSSSENSOR_BOOTROM       0x0071     /// Boot ROM Device ID
+#define GNSSSENSOR_FWIMAGE       0x0072     /// FW ROM image Device ID
+#define GNSSSENSOR_SRAM          0x0073     /// Internal SRAM block Device ID
+#define GNSSSENSOR_PNP           0x0074     /// Configuration Registers Module Device ID provided by gnsslib
+#define GNSSSENSOR_SPI_FLASH     0x0075     /// SD-card controller Device ID provided by gnsslib
+#define GNSSSENSOR_GPIO          0x0076     /// General purpose IOs Device ID provided by gnsslib
+#define GNSSSENSOR_RF_CONTROL    0x0077     /// RF front-end controller Device ID provided by gnsslib
+#define GNSSSENSOR_ENGINE        0x0078     /// GNSS Engine Device ID provided by gnsslib
+#define GNSSSENSOR_ENGINE_STUB   0x0068     /// GNSS Engine stub
+#define GNSSSENSOR_FSE_V2        0x0079     /// Fast Search Engines Device ID provided by gnsslib
+#define GNSSSENSOR_UART          0x007a     /// rs-232 UART Device ID
+#define GNSSSENSOR_ACCELEROMETER 0x007b     /// Accelerometer Device ID provided by gnsslib
+#define GNSSSENSOR_GYROSCOPE     0x007c     /// Gyroscope Device ID provided by gnsslib
+#define GNSSSENSOR_IRQCTRL       0x007d     /// Interrupt controller
+#define GNSSSENSOR_ETHMAC        0x007f
+#define GNSSSENSOR_DSU           0x0080
+#define GNSSSENSOR_GPTIMERS      0x0081
+
+
+#define TECH_INFERRED       0
+#define TECH_VIRTEX6        36
+#define TECH_KINTEX7        49
+
+
+
+#define ADDR_NASTI_SLAVE_FWIMAGE    0x00100000
+#define ADDR_NASTI_SLAVE_SRAM       0x10000000
+#define ADDR_NASTI_SLAVE_GPIO       0x80000000
+#define ADDR_NASTI_SLAVE_UART1      0x80001000
+#define ADDR_NASTI_SLAVE_IRQCTRL    0x80002000
+#define ADDR_NASTI_SLAVE_GNSSENGINE 0x80003000
+#define ADDR_NASTI_SLAVE_RFCTRL     0x80004000
+#define ADDR_NASTI_SLAVE_GPTIMERS   0x80005000
+#define ADDR_NASTI_SLAVE_FSEGPS     0x8000a000
+#define ADDR_NASTI_SLAVE_ETHMAC     0x80040000
+#define ADDR_NASTI_SLAVE_PNP        0xfffff000
+
+/* Interrupts pins assignments */
+#define CFG_IRQ_GNSS_ENGINE 0
+#define CFG_IRQ_UART1       1
+#define CFG_IRQ_ETH         2
+#define CFG_IRQ_SYS_TIMER   3
+
+/* Use this general purpose timer as a system timer */
+#define CFG_SYS_TIMER_IDX 0
+
+/* PNP */
+#define PNP_CONFIG_DEFAULT_BYTES 16
+
+/* uart configuration settings */
+#define UART_IRQ_FLAGS 0    // used in console driver
+
+
+#ifndef _ASMLANGUAGE
+
+typedef uint64_t adr_type;
+
+typedef struct IsrEntryType {
+    uint64_t arg;
+    uint64_t handler;
+} IsrEntryType;
+
+typedef void (*IRQ_HANDLER)(void *arg);
+
+
+#define __PNP	((volatile struct pnp_map *)ADDR_NASTI_SLAVE_PNP)
+/** @todo remove hardcoded addresses except __PNP. */
+#define __UART1	((volatile struct uart_map *)ADDR_NASTI_SLAVE_UART1)
+#define __IRQCTRL	((volatile struct irqctrl_map *)ADDR_NASTI_SLAVE_IRQCTRL)
+#define __TIMERS ((volatile struct gptimers_map *)ADDR_NASTI_SLAVE_GPTIMERS)
+
+/** 
+ * @brief Print Plug'n'Play information
+ *
+ * Each devices in a SOC implements sideband signals that are connected to
+ * PNP module. These signals provide such information as Vendor/Device IDs,
+ * memory address and allocated memory range.
+ */
+extern void soc_print_pnp();
+
+/**
+ * @brief Check hardware target configuration is it inferred or not.
+ *
+ * inferred hardware target is used for RTL simulation of the whole SOC design.
+ */
+extern uint32_t soc_is_rtl_simulation();
+
+#endif /* !_ASMLANGUAGE */
+
+#endif /* _RISCV_SOC_GNSS_H_ */
diff --git a/arch/riscv64/soc/riscv_gnss/soc_registers.h b/arch/riscv64/soc/riscv_gnss/soc_registers.h
new file mode 100644
index 0000000..4c53a46
--- /dev/null
+++ b/arch/riscv64/soc/riscv_gnss/soc_registers.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file SoC configuration macros for the Atmel SAM3 family processors.
+ *
+ * Refer to the datasheet for more information about these registers.
+ */
+
+#ifndef _RISCV_GNSS_SOC_REGS_H_
+#define _RISCV_GNSS_SOC_REGS_H_
+
+typedef struct PnpConfigType {
+    uint32_t xmask;
+    uint32_t xaddr;
+    uint16_t did;
+    uint16_t vid;
+    uint8_t size;
+    uint8_t rsrv[3];
+} PnpConfigType;
+
+typedef struct pnp_map {
+    volatile uint32_t hwid;         /// Read only HW ID
+    volatile uint32_t fwid;         /// Read/Write Firmware ID
+    volatile uint32_t tech;         /// Read only technology index
+    volatile uint32_t rsrv1;        /// 
+    volatile uint64_t idt;          /// 
+    volatile uint64_t malloc_addr;  /// debuggind memalloc pointer
+    volatile uint64_t malloc_size;  /// debugging memalloc size
+    volatile uint64_t fwdbg1;       /// FW debug register
+    volatile uint64_t rsrv[2];
+    PnpConfigType slaves[64];
+} pnp_map;
+
+typedef struct uart_map {
+    volatile uint32_t status;
+    volatile uint32_t scaler;
+    uint32_t rsrv[2];
+    volatile uint32_t data;
+} uart_map;
+
+
+typedef struct irqctrl_map {
+    volatile uint32_t irq_mask;     // 0x00: [RW] 1=disable; 0=enable
+    volatile uint32_t irq_pending;  // 0x04: [RW]
+    volatile uint32_t irq_clear;    // 0x08: [WO]
+    volatile uint32_t irq_rise;     // 0x0C: [WO]
+    volatile uint64_t isr_table;    // 0x10: [RW]
+    volatile uint64_t dbg_cause;    // 0x18: 
+    volatile uint64_t dbg_epc;      // 0x20: 
+    volatile uint32_t irq_lock;     // 0x28: interrupts wait while lock=1
+    volatile uint32_t irq_cause_idx;// 0x2c: 
+} irqctrl_map;
+
+
+typedef struct gptimer_type {
+    volatile uint32_t control;      // [0] = count_ena; [1] = irq_ena
+    volatile uint32_t rsv1;
+    volatile uint64_t cur_value;
+    volatile uint64_t init_value;
+} gptimer_type;
+
+typedef struct gptimers_map {
+    volatile uint64_t highcnt;
+    volatile uint32_t pending;
+    uint32_t rsv1[13];
+    gptimer_type tmr[2];
+} gptimer_map;
+
+#endif /* _RISCV_GNSS_SOC_REGS_H_ */
diff --git a/boards/riscv_gnss/Kconfig.board b/boards/riscv_gnss/Kconfig.board
new file mode 100644
index 0000000..f6662ef
--- /dev/null
+++ b/boards/riscv_gnss/Kconfig.board
@@ -0,0 +1,6 @@
+
+config  BOARD_RISCV_GNSS
+        bool "RISC-V based FPGA SoC"
+        depends on SOC_RISCV_GNSS
+	help
+	The RISC-v VHDL FPGA development boards
diff --git a/boards/riscv_gnss/Kconfig.defconfig b/boards/riscv_gnss/Kconfig.defconfig
new file mode 100644
index 0000000..87a8af3
--- /dev/null
+++ b/boards/riscv_gnss/Kconfig.defconfig
@@ -0,0 +1,8 @@
+
+if BOARD_RISCV_GNSS
+
+config BOARD
+        default riscv_gnss
+
+
+endif # BOARD_RISCV_GNSS
diff --git a/boards/riscv_gnss/Makefile b/boards/riscv_gnss/Makefile
new file mode 100644
index 0000000..9c25546
--- /dev/null
+++ b/boards/riscv_gnss/Makefile
@@ -0,0 +1,5 @@
+ccflags-y += -I$(srctree)/include/drivers
+ccflags-y += -I$(srctree)/drivers
+asflags-y := ${ccflags-y}
+
+obj-y += board.o
diff --git a/boards/riscv_gnss/board.c b/boards/riscv_gnss/board.c
new file mode 100644
index 0000000..d836c65
--- /dev/null
+++ b/boards/riscv_gnss/board.c
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2011-2015, Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <nanokernel.h>
+#include "board.h"
+#include <uart.h>
+#include <device.h>
+#include <init.h>
diff --git a/boards/riscv_gnss/board.h b/boards/riscv_gnss/board.h
new file mode 100644
index 0000000..55029f6
--- /dev/null
+++ b/boards/riscv_gnss/board.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __INC_BOARD_H
+#define __INC_BOARD_H
+
+#include <soc.h>
+
+#endif /* __INC_BOARD_H */
diff --git a/boards/riscv_gnss/riscv_gnss_defconfig b/boards/riscv_gnss/riscv_gnss_defconfig
new file mode 100644
index 0000000..e34940e
--- /dev/null
+++ b/boards/riscv_gnss/riscv_gnss_defconfig
@@ -0,0 +1,26 @@
+CONFIG_RISCV64=y
+CONFIG_SOC_RISCV_GNSS=y
+CONFIG_BOARD_RISCV_GNSS=y
+CONFIG_SERIAL=y
+CONFIG_CONSOLE=y
+CONFIG_UART_CONSOLE=y
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_SYS_CLOCK_EXISTS=y
+CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=60000000
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=100
+CONFIG_UART_RISCV_GNSS=y
+CONFIG_RISCV_SYSTIMER=y
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+CONFIG_MAIN_STACK_SIZE=16384
+CONFIG_ISR_STACK_SIZE=256
+CONFIG_KERNEL_EVENT_LOGGER_BUFFER_SIZE=16
+CONFIG_NUM_IRQS=3
+CONFIG_KERNEL_EVENT_LOGGER=y
+CONFIG_UART_CONSOLE_ON_DEV_NAME="UART_0"
+CONFIG_UART_INTERRUPT_DRIVEN=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+CONFIG_CONSOLE_HANDLER_SHELL_STACKSIZE=2000
+CONFIG_CONSOLE_HAS_DRIVER=y
+CONFIG_PRINTK=y
diff --git a/drivers/console/console_handler_shell.c b/drivers/console/console_handler_shell.c
index 17ce590..2f561ac 100644
--- a/drivers/console/console_handler_shell.c
+++ b/drivers/console/console_handler_shell.c
@@ -24,7 +24,7 @@
 #include <stdio.h>
 #include <string.h>
 
-#include <console/uart_console.h>
+#include <drivers/console/uart_console.h>
 #include <misc/printk.h>
 #include <misc/util.h>
 
@@ -207,8 +207,8 @@ static void shell(int arg1, int arg2)
 		}
 
 		/* Execute callback with arguments */
-		if (cb(argc, argv) < 0) {
-			show_cmd_help(argc, argv);
+		if (cb((int)argc, argv) < 0) {
+			show_cmd_help((int)argc, argv);
 		}
 
 		nano_fiber_fifo_put(&avail_queue, cmd);
@@ -236,7 +236,7 @@ static uint8_t completion(char *line, uint8_t len)
 		/* more commands match, print first match */
 		if (first_match && (common_chars < 0)) {
 			printk("\n%s\n", first_match);
-			common_chars = strlen(first_match);
+			common_chars = (int)strlen(first_match);
 		}
 
 		/* cut common part of matching names */
@@ -266,7 +266,7 @@ static uint8_t completion(char *line, uint8_t len)
 			line[i] = first_match[i];
 		}
 	} else {
-		common_chars = strlen(first_match);
+		common_chars = (int)strlen(first_match);
 
 		/* full command name with trailing spaces, do nothing */
 		if (len > common_chars) {
diff --git a/drivers/console/uart_console.c b/drivers/console/uart_console.c
index 462eddf..7e68b2d 100644
--- a/drivers/console/uart_console.c
+++ b/drivers/console/uart_console.c
@@ -36,7 +36,7 @@
 
 #include <board.h>
 #include <uart.h>
-#include <console/uart_console.h>
+#include <drivers/console/uart_console.h>
 #include <toolchain.h>
 #include <sections.h>
 #include <atomic.h>
diff --git a/drivers/random/rand32_timestamp.c b/drivers/random/rand32_timestamp.c
index f872d53..64b8748 100644
--- a/drivers/random/rand32_timestamp.c
+++ b/drivers/random/rand32_timestamp.c
@@ -28,6 +28,8 @@
 #include <arch/cpu.h>
 #include <drivers/rand32.h>
 
+extern uint32_t _do_read_cpu_timestamp32(void);
+
 /**
  *
  * @brief Initialize the random number generator
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 3a9721c..a9cbcfd 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -83,4 +83,6 @@ source "drivers/serial/Kconfig.nrf5"
 
 source "drivers/serial/Kconfig.altera_jtag"
 
+source "drivers/serial/Kconfig.rvgnss"
+
 endif
diff --git a/drivers/serial/Kconfig.rvgnss b/drivers/serial/Kconfig.rvgnss
new file mode 100644
index 0000000..97a60fc
--- /dev/null
+++ b/drivers/serial/Kconfig.rvgnss
@@ -0,0 +1,7 @@
+menuconfig UART_RISCV_GNSS
+	bool "RISC-V serial driver"
+	default y
+	select SERIAL_HAS_DRIVER
+	help
+	This option enables the UART driver for FPGA generic SoC
+	based on RISC-V ISA family processors. 
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index f5c1052..45526a9 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_UART_QMSI)		+= uart_qmsi.o
 obj-$(CONFIG_UART_STM32)	+= uart_stm32.o
 obj-$(CONFIG_UART_NRF5)         += uart_nrf5.o
 obj-$(CONFIG_UART_ALTERA_JTAG)  += uart_altera_jtag.o
+obj-$(CONFIG_UART_RISCV_GNSS)	+= uart_gnss.o
diff --git a/drivers/serial/uart_gnss.c b/drivers/serial/uart_gnss.c
new file mode 100644
index 0000000..d2250f2
--- /dev/null
+++ b/drivers/serial/uart_gnss.c
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2016, GNSS Sensor Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <nanokernel.h>
+#include <arch/cpu.h>
+#include <sections.h>
+#include <misc/__assert.h>
+#include <stdint.h>
+#include <misc/util.h>
+#include <string.h>
+#include <board.h>
+#include <init.h>
+#include <uart.h>
+#include <irq.h>
+
+#define UART_STATUS_TX_FULL     0x00000001
+#define UART_STATUS_TX_EMPTY    0x00000002
+#define UART_STATUS_RX_FULL     0x00000010
+#define UART_STATUS_RX_EMPTY    0x00000020
+#define UART_STATUS_ERR_PARITY  0x00000100
+#define UART_STATUS_ERR_STOPBIT 0x00000200
+#define UART_CONTROL_RX_IRQ_ENA 0x00002000
+#define UART_CONTROL_TX_IRQ_ENA 0x00004000
+#define UART_CONTROL_PARITY_ENA 0x00008000
+
+
+static struct uart_driver_api uart_gnss_driver_api;
+/* Device data structure */
+struct uart_gnss_dev_data_t {
+	uint32_t baud_rate;	/* Baud rate */
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	uart_irq_callback_t     cb;     /**< Callback function pointer */
+#endif
+};
+
+static struct uart_gnss_dev_data_t uart_gnss_dev_data_0 = {
+	115200,  // .baud_rate
+    NULL
+};
+
+
+/**
+ * @brief Interrupt service routine.
+ *
+ * This simply calls the callback function, if one exists.
+ *
+ * @param arg Argument to ISR.
+ *
+ * @return N/A
+ */
+void uart_gnss_isr(void *arg) {
+    struct device *dev = (struct device *)arg;
+    struct uart_gnss_dev_data_t *data =
+        (struct uart_gnss_dev_data_t *)dev->driver_data;
+    if (data->cb) {
+        data->cb(dev);
+    }
+}
+
+/*
+ * @brief Output a character to serial port
+ *
+ * @param dev UART device struct
+ * @param c character to output
+ */
+unsigned char uart_gnss_poll_out(struct device *dev, unsigned char c)
+{
+	/* wait for transmitter to ready to accept a character */
+    uint32_t status = READ32(&__UART1->status);
+	while (status & UART_STATUS_TX_FULL) {
+        status = READ32(&__UART1->status);
+	}
+	WRITE32(&__UART1->data, c);
+	return c;
+}
+
+static int uart_gnss_poll_in(struct device *dev, unsigned char *c)
+{
+	return -ENOTSUP;
+
+}
+
+/**
+ * @brief Read data from FIFO
+ *
+ * @param dev UART device struct
+ * @param rx_data Pointer to data container
+ * @param size Container size
+ *
+ * @return Number of bytes read
+ */
+static int uart_gnss_fifo_read(struct device *dev, uint8_t *rx_data,
+				    const int size)
+{
+	uint32_t status = READ32(&__UART1->status);
+	uint8_t num_rx = 0;
+
+	while ((size - num_rx > 0) && ((status & UART_STATUS_RX_EMPTY) == 0)) {
+		rx_data[num_rx++] = (uint8_t)READ32(&__UART1->data);
+        status = READ32(&__UART1->status);
+	}
+
+	return num_rx;
+}
+
+void uart_gnss_irq_tx_enable(struct device *dev) {
+	uint32_t status = READ32(&__UART1->status);
+    status |= UART_CONTROL_TX_IRQ_ENA;
+    WRITE32(&__UART1->status, status);
+}
+
+void uart_gnss_irq_tx_disable(struct device *dev) {
+	uint32_t status = READ32(&__UART1->status);
+    status &= ~UART_CONTROL_TX_IRQ_ENA;
+    WRITE32(&__UART1->status, status);
+}
+
+void uart_gnss_irq_rx_enable(struct device *dev) {
+	uint32_t status = READ32(&__UART1->status);
+    status |= UART_CONTROL_RX_IRQ_ENA;
+    WRITE32(&__UART1->status, status);
+}
+
+void uart_gnss_irq_rx_disable(struct device *dev) {
+	uint32_t status = READ32(&__UART1->status);
+    status &= ~UART_CONTROL_RX_IRQ_ENA;
+    WRITE32(&__UART1->status, status);
+}
+
+int uart_gnss_irq_tx_empty(struct device *dev) {
+	uint32_t status = READ32(&__UART1->status);
+	return ((status & UART_STATUS_TX_EMPTY) ? 1: 0);
+}
+
+/**
+ * @brief Check if Rx IRQ has been raised
+ *
+ * @param dev UART device struct
+ *
+ * @return 1 if an IRQ is ready, 0 otherwise
+ */
+static int uart_gnss_irq_rx_ready(struct device *dev)
+{
+	uint32_t status = READ32(&__UART1->status);
+
+	return ((status & UART_STATUS_RX_EMPTY) ? 0: 1);
+}
+
+
+/**
+ * @brief Check if Tx or Rx IRQ is pending
+ *
+ * @param dev UART device struct
+ *
+ * @return 1 if a Tx or Rx IRQ is pending, 0 otherwise
+ */
+static int uart_gnss_irq_is_pending(struct device *dev)
+{
+	/* Look only at Tx and Rx data interrupt flags */
+	return uart_gnss_irq_rx_ready(dev);
+}
+
+
+/**
+ * @brief Update IRQ status
+ *
+ * @param dev UART device struct
+ *
+ * @return Always 1
+ */
+static int uart_gnss_irq_update(struct device *dev)
+{
+	return 1;
+}
+
+/**
+ * @brief Set the callback function pointer for IRQ.
+ *
+ * @param dev UART device struct
+ * @param cb Callback function pointer.
+ *
+ * @return N/A
+ */
+static void uart_gnss_irq_callback_set(struct device *dev,
+                                        uart_irq_callback_t cb)
+{
+	struct uart_gnss_dev_data_t * const dev_data = dev->driver_data;
+	dev_data->cb = cb;
+}
+
+static struct uart_driver_api uart_gnss_driver_api = {
+	uart_gnss_poll_in,  // poll_in
+	uart_gnss_poll_out, // poll_out
+	NULL,//int (*err_check)(struct device *dev);
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+	NULL,//int (*fifo_fill)(struct device *dev, const uint8_t *tx_data, int len);
+	uart_gnss_fifo_read,
+	uart_gnss_irq_tx_enable,
+	uart_gnss_irq_tx_disable,
+	NULL,//int (*irq_tx_ready)(struct device *dev);
+	uart_gnss_irq_rx_enable,
+	uart_gnss_irq_rx_disable,
+	uart_gnss_irq_tx_empty,
+	uart_gnss_irq_rx_ready,
+	NULL,//void (*irq_err_enable)(struct device *dev);
+	NULL,//void (*irq_err_disable)(struct device *dev);
+	uart_gnss_irq_is_pending,
+	uart_gnss_irq_update,
+	NULL,//int (*irq_input_hook)(struct device *dev, uint8_t byte);
+    uart_gnss_irq_callback_set,
+#endif
+
+#ifdef CONFIG_UART_LINE_CTRL
+	NULL,//int (*line_ctrl_set)(struct device *dev, uint32_t ctrl, uint32_t val);
+#endif
+
+#ifdef CONFIG_UART_DRV_CMD
+	NULL,//int (*drv_cmd)(struct device *dev, uint32_t cmd, uint32_t p);
+#endif
+};
+
+/**
+ * @brief Initialize fake serial port
+ *
+ * @param dev UART device struct
+ *
+ * @return DEV_OK
+ */
+static int uart_gnss_init(struct device *dev)
+{
+	dev->driver_api = &uart_gnss_driver_api;
+    dev->driver_data = &uart_gnss_dev_data_0;
+
+    // Speed-up RTL simulation avoidig long polling of the status register.
+    if (soc_is_rtl_simulation() != 0) {
+        WRITE32(&__UART1->scaler, 20);
+    } else {
+        WRITE32(&__UART1->scaler, CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC/115200/2);
+    }
+
+#ifdef CONFIG_UART_INTERRUPT_DRIVEN
+    uart_gnss_irq_rx_enable(dev);
+	IRQ_CONNECT(CFG_IRQ_UART1, CFG_IRQ_UART1, uart_gnss_isr, dev, UART_IRQ_FLAGS);
+	irq_enable(CFG_IRQ_UART1);
+#endif
+	return 0;
+}
+
+
+DEVICE_INIT(uart_gnss0, "UART_0", &uart_gnss_init,
+			NULL, NULL,
+			PRIMARY, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);
diff --git a/drivers/timer/Kconfig b/drivers/timer/Kconfig
index dd3f426..fd25a45 100644
--- a/drivers/timer/Kconfig
+++ b/drivers/timer/Kconfig
@@ -151,6 +151,14 @@ config ALTERA_AVALON_TIMER
 	with Nios II and possibly other Altera soft CPUs. It provides the
 	standard "system clock driver" interfaces.
 
+config RISCV_SYSTIMER
+	bool "RISC-V System timer"
+	default y
+	depends on RISCV64
+	help
+	This module implements a kernel device driver for the Rocket-chip
+	processor. It provides the standard "system clock driver" interfaces.
+
 config SYSTEM_CLOCK_DISABLE
 	bool "API to disable system clock"
 	default n
diff --git a/drivers/timer/Makefile b/drivers/timer/Makefile
index d1b440b..3576af6 100644
--- a/drivers/timer/Makefile
+++ b/drivers/timer/Makefile
@@ -2,6 +2,7 @@ obj-$(CONFIG_HPET_TIMER) += hpet.o
 obj-$(CONFIG_LOAPIC_TIMER) += loapic_timer.o
 obj-$(CONFIG_ARCV2_TIMER) += arcv2_timer0.o
 obj-$(CONFIG_ALTERA_AVALON_TIMER) += altera_avalon_timer.o
+obj-$(CONFIG_RISCV_SYSTIMER) += riscv_systimer.o
 
 _CORTEX_M_SYSTICK_AND_GDB_INFO_yy = y
 obj-$(CONFIG_CORTEX_M_SYSTICK) += cortex_m_systick.o
diff --git a/drivers/timer/riscv_systimer.c b/drivers/timer/riscv_systimer.c
new file mode 100644
index 0000000..14349f7
--- /dev/null
+++ b/drivers/timer/riscv_systimer.c
@@ -0,0 +1,127 @@
+#include <nanokernel.h>
+#include <toolchain.h>
+#include <sections.h>
+#include <sys_clock.h>
+#include <drivers/system_timer.h>
+#include <nano_private.h>
+#include <board.h>
+#include <irq.h>
+
+#ifdef CONFIG_MICROKERNEL
+
+#include <microkernel.h>
+
+extern struct nano_stack _k_command_stack;
+
+#endif /*  CONFIG_MICROKERNEL */
+
+/* running total of timer count */
+static uint32_t __noinit cycles_per_tick;
+static uint32_t accumulated_cycle_count;
+
+#define GPTIMER_CONTROL_COUNT_ENA   0x1
+#define GPTIMER_CONTROL_IRQ_ENA     0x2
+
+/**
+ *
+ * @brief Read the platform's timer hardware
+ *
+ * This routine returns the current time in terms of timer hardware clock
+ * cycles.
+ *
+ * @return up counter of elapsed clock cycles
+ *
+ * \INTERNAL WARNING
+ * If this routine is ever enhanced to return all 64 bits of the counter
+ * it will need to call _hpetMainCounterAtomic().
+ */
+
+uint32_t sys_cycle_get_32(void)
+{
+    //return (uint32_t)READ64(&__TIMERS->tmr[CFG_SYS_TIMER_IDX].cur_value);
+	return (uint32_t)READ64(&__TIMERS->highcnt);
+}
+
+uint64_t sys_cycle_get_64(void)
+{
+	return READ64(&__TIMERS->highcnt);
+}
+
+#ifdef CONFIG_TICKLESS_IDLE
+static INLINE void update_accumulated_count(void)
+{
+	accumulated_cycle_count += (_sys_idle_elapsed_ticks * cycles_per_tick);
+}
+#else /* CONFIG_TICKLESS_IDLE */
+static INLINE void update_accumulated_count(void)
+{
+	accumulated_cycle_count += cycles_per_tick;
+}
+#endif /* CONFIG_TICKLESS_IDLE */
+
+/**
+ *
+ * @brief System clock periodic tick handler
+ *
+ * This routine handles the system clock periodic tick interrupt. It always
+ * announces one tick.
+ *
+ * @return N/A
+ */
+void _timer_int_handler(void *unused)
+{
+	ARG_UNUSED(unused);
+
+	/* clear the interrupt by writing 0 to IP bit of the control register */
+    WRITE32(&__IRQCTRL->irq_clear, (1u << CFG_IRQ_SYS_TIMER));
+    WRITE32(&__TIMERS->pending, 0);
+
+#if defined(CONFIG_TICKLESS_IDLE)
+	timer0_limit_register_set(cycles_per_tick - 1);
+
+	_sys_idle_elapsed_ticks = 1;
+#endif
+
+	update_accumulated_count();
+	_sys_clock_tick_announce();
+}
+
+/*
+ * @brief initialize the tickless idle feature
+ *
+ * This routine initializes the tickless idle feature.
+ *
+ * @return N/A
+ */
+static void tickless_idle_init(void) {}
+
+int _sys_clock_driver_init(struct device *device) {
+	ARG_UNUSED(device);
+
+	/* ensure that the timer will not generate interrupts */
+    WRITE32(&__TIMERS->tmr[CFG_SYS_TIMER_IDX].control, 0);
+
+    sys_clock_hw_cycles_per_tick = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC /
+                                    sys_clock_ticks_per_sec;
+	cycles_per_tick = sys_clock_hw_cycles_per_tick;
+    accumulated_cycle_count = 0;
+
+	IRQ_CONNECT(CFG_IRQ_SYS_TIMER, 0, _timer_int_handler, 0, 0);
+
+	/*
+	 * Set the reload value to achieve the configured tick rate, enable the
+	 * counter and interrupt generation.
+	 */
+
+	tickless_idle_init();
+
+    WRITE64(&__TIMERS->tmr[CFG_SYS_TIMER_IDX].init_value, cycles_per_tick - 1);
+    WRITE32(&__TIMERS->tmr[CFG_SYS_TIMER_IDX].control, 
+        GPTIMER_CONTROL_COUNT_ENA | GPTIMER_CONTROL_IRQ_ENA);
+
+	/* everything has been configured: safe to enable the interrupt */
+
+	irq_enable(CFG_IRQ_SYS_TIMER);
+
+    return 0;
+}
diff --git a/include/arch/cpu.h b/include/arch/cpu.h
index 11f5b8e..513f101 100644
--- a/include/arch/cpu.h
+++ b/include/arch/cpu.h
@@ -27,6 +27,8 @@
 #include <arch/arc/arch.h>
 #elif defined(CONFIG_NIOS2)
 #include <arch/nios2/arch.h>
+#elif defined(CONFIG_RISCV64)
+#include <arch/riscv64/arch.h>
 #else
 #error "Unknown Architecture"
 #endif
diff --git a/include/arch/riscv64/arch.h b/include/arch/riscv64/arch.h
new file mode 100644
index 0000000..967de3c
--- /dev/null
+++ b/include/arch/riscv64/arch.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief RISC-V specific nanokernel interface header
+ *
+ * This header contains the ARC specific nanokernel interface.  It is
+ * included by the nanokernel interface architecture-abstraction header
+ * (nanokernel/cpu.h)
+ */
+
+#ifndef _RISCV_ARCH__H_
+#define _RISCV_ARCH__H_
+
+#include <stdint.h>
+#include <toolchain.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define STACK_ALIGN  8
+
+#ifdef _ASMLANGUAGE
+
+
+#else // !_ASMLANGUAGE
+/** interrupt/exception/error related definitions */
+typedef void (*NANO_EOI_GET_FUNC) (void *);
+
+/**
+ * @brief Disable all interrupts on the CPU (inline)
+ *
+ * This routine disables interrupts.  It can be called from either interrupt,
+ * task or fiber level.  This routine returns an architecture-dependent
+ * lock-out key representing the "interrupt disable state" prior to the call;
+ * this key can be passed to irq_unlock() to re-enable interrupts.
+ *
+ * The lock-out key should only be used as the argument to the irq_unlock()
+ * API.  It should never be used to manually re-enable interrupts or to inspect
+ * or manipulate the contents of the source register.
+ *
+ * This function can be called recursively: it will return a key to return the
+ * state of interrupt locking to the previous level.
+ *
+ * WARNINGS
+ * Invoking a kernel routine with interrupts locked may result in
+ * interrupts being re-enabled for an unspecified period of time.  If the
+ * called routine blocks, interrupts will be re-enabled while another
+ * thread executes, or while the system is idle.
+ *
+ * The "interrupt disable state" is an attribute of a thread.  Thus, if a
+ * fiber or task disables interrupts and subsequently invokes a kernel
+ * routine that causes the calling thread to block, the interrupt
+ * disable state will be restored when the thread is later rescheduled
+ * for execution.
+ *
+ * @return An architecture-dependent lock-out key representing the
+ * "interrupt disable state" prior to the call.
+ *
+ */
+
+extern unsigned int _arch_irq_lock(void);
+
+
+/**
+ *
+ * @brief Enable all interrupts on the CPU (inline)
+ *
+ * This routine re-enables interrupts on the CPU.  The @a key parameter
+ * is an architecture-dependent lock-out key that is returned by a previous
+ * invocation of irq_lock().
+ *
+ * This routine can be called from either interrupt, task or fiber level.
+ *
+ * @return N/A
+ *
+ */
+
+extern void _arch_irq_unlock(unsigned int key);
+
+/**
+ *
+ * @brief Read interrupts state on the CPU (inline)
+ *
+ * This routine check interrupts on the CPU.
+  * This routine can be called from either interrupt, task or fiber level.
+ *
+ * @return N/A
+ *
+ */
+
+extern unsigned int _arch_irq_lock_state();
+
+/**
+ *
+ * @brief Enable an interrupt line
+ *
+ * Clear possible pending interrupts on the line, and enable the interrupt
+ * line. After this call, the CPU will receive interrupts for the specified
+ * <irq>.
+ *
+ * @return N/A
+ */
+extern void _arch_irq_enable(unsigned int irq);
+
+/**
+ *
+ * @brief Disable an interrupt line
+ *
+ * Disable an interrupt line. After this call, the CPU will stop receiving
+ * interrupts for the specified <irq>.
+ *
+ * @return N/A
+ */
+extern void _arch_irq_disable(unsigned int irq);
+
+/**
+ * Configure a dynamic interrupt.
+ *
+ * @param irq IRQ line number
+ * @param priority Interrupt priority
+ * @param routine Interrupt service routine
+ * @param parameter ISR parameter
+ * @param flags Arch-specific IRQ configuration flags
+ *
+ * @return The vector assigned to this interrupt
+ */
+int _arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,
+			     void (*routine)(void *parameter), void *parameter,
+			     uint32_t flags);
+
+
+/**
+ * Configure a static interrupt.
+ *
+ * All arguments must be computable by the compiler at build time; if this
+ * can't be done use irq_connect_dynamic() instead.
+ *
+ * Internally this function does a few things:
+ *
+ * 1. The enum statement has no effect but forces the compiler to only
+ * accept constant values for the irq_p parameter, very important as the
+ * numerical IRQ line is used to create a named section.
+ *
+ * 2. An instance of _IsrTableEntry is created containing the ISR and its
+ * parameter. If you look at how _sw_isr_table is created, each entry in the
+ * array is in its own section named by the IRQ line number. What we are doing
+ * here is to override one of the default entries (which points to the
+ * spurious IRQ handler) with what was supplied here.
+ *
+ * 3. The priority level for the interrupt is configured by a call to
+ * _irq_priority_set()
+ *
+ * @param irq_p IRQ line number
+ * @param priority_p Interrupt priority
+ * @param isr_p Interrupt service routine
+ * @param isr_param_p ISR parameter
+ * @param flags_p IRQ triggering options (currently unused)
+ *
+ * @return The vector assigned to this interrupt
+ */
+#define _ARCH_IRQ_CONNECT(irq_p, priority_p, isr_p, isr_param_p, flags_p) \
+	_arch_irq_connect_dynamic(irq_p, priority_p, isr_p, isr_param_p, \
+				  flags_p)
+
+
+
+/**
+ * The NANO_SOFT_IRQ macro must be used as the value for the @a irq parameter
+ * to NANO_CPU_INT_REGSITER when connecting to an interrupt that does not
+ * correspond to any IRQ line (such as spurious vector or SW IRQ)
+ */
+#define NANO_SOFT_IRQ	((unsigned int) (-1))
+
+/**
+ * @brief Nanokernel Exception Stack Frame
+ *
+ * A pointer to an "exception stack frame" (ESF) is passed as an argument
+ * to exception handlers registered via nanoCpuExcConnect().  As the system
+ * always operates at ring 0, only the EIP, CS and EFLAGS registers are pushed
+ * onto the stack when an exception occurs.
+ *
+ * The exception stack frame includes the volatile registers (EAX, ECX, and
+ * EDX) as well as the 5 non-volatile registers (EDI, ESI, EBX, EBP and ESP).
+ * Those registers are pushed onto the stack by _ExcEnt().
+ */
+
+typedef struct nanoEsf {
+	unsigned int esp;
+	unsigned int ebp;
+	unsigned int ebx;
+	unsigned int esi;
+	unsigned int edi;
+	unsigned int edx;
+	unsigned int eax;
+	unsigned int ecx;
+	unsigned int errorCode;
+	unsigned int eip;
+	unsigned int cs;
+	unsigned int eflags;
+} NANO_ESF;
+
+/**
+ * @brief Nanokernel "interrupt stack frame" (ISF)
+ *
+ * An "interrupt stack frame" (ISF) as constructed by the processor
+ * and the interrupt wrapper function _IntEnt().  As the system always operates
+ * at ring 0, only the EIP, CS and EFLAGS registers are pushed onto the stack
+ * when an interrupt occurs.
+ *
+ * The interrupt stack frame includes the volatile registers EAX, ECX, and EDX
+ * pushed on the stack by _IntEnt().
+ */
+
+typedef struct nanoIsf {
+	unsigned int edx;
+	unsigned int ecx;
+	unsigned int eax;
+	unsigned int eip;
+	unsigned int cs;
+	unsigned int eflags;
+} NANO_ISF;
+
+
+/*
+ * Reason codes passed to both _NanoFatalErrorHandler()
+ * and _SysFatalErrorHandler().
+ */
+
+/** Unhandled exception/interrupt */
+#define _NANO_ERR_SPURIOUS_INT		 (0)
+/** Page fault */
+#define _NANO_ERR_PAGE_FAULT		 (1)
+/** General protection fault */
+#define _NANO_ERR_GEN_PROT_FAULT	 (2)
+/** Invalid task exit */
+#define _NANO_ERR_INVALID_TASK_EXIT  (3)
+/** Stack corruption detected */
+#define _NANO_ERR_STACK_CHK_FAIL	 (4)
+/** Kernel Allocation Failure */
+#define _NANO_ERR_ALLOCATION_FAIL    (5)
+/** Unhandled exception */
+#define _NANO_ERR_CPU_EXCEPTION		(6)
+
+
+#include <stddef.h>	/* for size_t */
+
+extern void	nano_cpu_idle(void);
+
+/** Nanokernel provided routine to report any detected fatal error. */
+extern FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
+						 const NANO_ESF * pEsf);
+/** User provided routine to handle any detected fatal error post reporting. */
+extern FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
+						const NANO_ESF * pEsf);
+/** Dummy ESF for fatal errors that would otherwise not have an ESF */
+extern const NANO_ESF _default_esf;
+
+#endif  // _ASMLANGUAGE/!_ASMLANGUAGE
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _RISCV_ARCH__H_ */
diff --git a/include/arch/riscv64/linker.ld b/include/arch/riscv64/linker.ld
new file mode 100644
index 0000000..6dca0e4
--- /dev/null
+++ b/include/arch/riscv64/linker.ld
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2014-2015 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @brief Common parts of the linker scripts for the ARCv2/EM targets.
+ */
+
+#define _LINKER
+#define _ASMLANGUAGE
+
+#include <autoconf.h>
+#include <sections.h>
+
+#if defined(CONFIG_NSIM)
+	EXTERN(_VectorTable)
+#endif
+
+#include <linker-defs.h>
+#include <linker-tool.h>
+
+/* physical address of RAM */
+#ifdef CONFIG_XIP
+	#define ROMABLE_REGION FLASH
+	#define RAMABLE_REGION SRAM
+#else
+	#define ROMABLE_REGION SRAM
+	#define RAMABLE_REGION SRAM
+#endif
+
+#if defined(CONFIG_XIP)
+	#define _DATA_IN_ROM __data_rom_start
+#else
+	#define _DATA_IN_ROM
+#endif
+
+MEMORY {
+	FLASH (rx) : ORIGIN = FLASH_START, LENGTH = FLASH_SIZE*1k
+	SRAM  (rwx) : ORIGIN = SRAM_START,  LENGTH = SRAM_SIZE*1k
+	DCCM  (rw) : ORIGIN = DCCM_START,  LENGTH = DCCM_SIZE*1k
+}
+
+SECTIONS {
+	GROUP_START(ROMABLE_REGION)
+
+	SECTION_PROLOGUE(_TEXT_SECTION_NAME,,ALIGN(1024)) {
+		_image_rom_start = .;
+		_image_text_start = .;
+
+/* when !XIP, .text is in RAM, and vector table must be at its very start */
+
+		KEEP(*(.exc_vector_table))
+		KEEP(*(".exc_vector_table.*"))
+
+
+		KEEP(*(.irq_vector_table))
+		KEEP(*(".irq_vector_table.*"))
+
+#ifdef CONFIG_VERSION_HEADER
+		*(.version_header)
+		KEEP(*(".version_header*"))
+#endif
+#ifndef CONFIG_SW_ISR_TABLE_DYNAMIC
+		KEEP(*(.isr_irq*))
+
+		/*The following sections maps the location of the different rows for
+		the _sw_isr_table. Each row maps to an IRQ entry (handler, argument).*/
+		/*In ARC architecture, IRQ 0-15 are reserved for the system and are not
+		assignable by the user, for that reason the linker sections start
+		on IRQ 16*/
+		/* sections for IRQ16-19 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[1][6-9])))
+		/* sections for IRQ20-99 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[2-9][0-9])))
+		/* sections for IRQ100-999 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[1-9][0-9][0-9])))
+#endif
+
+		*(.text)
+		*(".text.*")
+		*(.gnu.linkonce.t.*)
+
+		_image_text_end = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
+
+	SECTION_PROLOGUE (devconfig, (OPTIONAL),)
+	{
+		__devconfig_start = .;
+		*(".devconfig.*")
+		KEEP(*(SORT_BY_NAME(".devconfig*")))
+		__devconfig_end = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
+
+	SECTION_PROLOGUE(gpio_compat, (OPTIONAL),)
+	{
+		__gpio_compat_start = .;
+		*(".gpio_compat.*")
+		KEEP(*(SORT_BY_NAME(".gpio_compat*")))
+		__gpio_compat_end = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
+
+#ifdef CONFIG_CPLUSPLUS
+	SECTION_PROLOGUE(_CTOR_SECTION_NAME,,) {
+		/*
+		 * The compiler fills the constructor pointers table below, hence
+		 * symbol __CTOR_LIST__ must be aligned on 4 byte boundary.
+		 * To align with the C++ standard, the first element of the array
+		 * contains the number of actual constructors. The last element is
+		 * NULL.
+		 */
+		. = ALIGN(4);
+		__CTOR_LIST__ = .;
+		LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)
+		KEEP(*(SORT_BY_NAME(".ctors*")))
+		LONG(0)
+		__CTOR_END__ = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
+
+	SECTION_PROLOGUE(init_array, (OPTIONAL),)
+	{
+		. = ALIGN(4);
+		__init_array_start = .;
+		KEEP(*(SORT_BY_NAME(".init_array*")))
+		__init_array_end = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
+#endif
+
+	SECTION_PROLOGUE(_RODATA_SECTION_NAME,,) {
+		*(.rodata)
+		*(".rodata.*")
+		*(.gnu.linkonce.r.*)
+	} GROUP_LINK_IN(ROMABLE_REGION)
+
+	_image_rom_end = .;
+	__data_rom_start = ALIGN(4);	/* XIP imaged DATA ROM start addr */
+
+	GROUP_END(ROMABLE_REGION)
+
+	GROUP_START(RAMABLE_REGION)
+
+#if defined(CONFIG_XIP)
+	SECTION_AT_PROLOGUE(_DATA_SECTION_NAME,,,_DATA_IN_ROM) {
+#else
+	SECTION_PROLOGUE(_DATA_SECTION_NAME,,) {
+#endif
+
+/* when XIP, .text is in ROM, but vector table must be at start of .data */
+
+		_image_ram_start = .;
+		__data_ram_start = .;
+		*(.data)
+		*(".data.*")
+
+#if CONFIG_SW_ISR_TABLE_DYNAMIC
+		KEEP(*(.isr_irq*))
+
+		/*The following sections maps the location of the different rows for
+		the _sw_isr_table. Each row maps to an IRQ entry (handler, argument).*/
+		/*In ARC architecture, IRQ 0-15 are reserved for the system and are not
+		assignable by the user, for that reason the linker sections start
+		on IRQ 16*/
+		/* sections for IRQ16-19 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[1][6-9])))
+		/* sections for IRQ20-99 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[2-9][0-9])))
+		/* sections for IRQ100-999 */
+		KEEP(*(SORT(.gnu.linkonce.isr_irq[1-9][0-9][0-9])))
+#endif
+	} GROUP_LINK_IN(RAMABLE_REGION)
+
+	SECTION_PROLOGUE(initlevel, (OPTIONAL),)
+	{
+		DEVICE_INIT_SECTIONS()
+	} GROUP_LINK_IN(RAMABLE_REGION)
+
+	__data_ram_end = .;
+
+	SECTION_PROLOGUE(_BSS_SECTION_NAME,(NOLOAD),) {
+		/*
+		 * For performance, BSS section is assumed to be 4 byte aligned and
+		 * a multiple of 4 bytes
+		 */
+		. = ALIGN(4);
+		__bss_start = .;
+		*(.bss)
+		*(".bss.*")
+		COMMON_SYMBOLS
+		/*
+		 * BSP clears this memory in words only and doesn't clear any
+		 * potential left over bytes.
+		 */
+		__bss_end = ALIGN(4);
+	} GROUP_LINK_IN(RAMABLE_REGION)
+
+	SECTION_PROLOGUE(_NOINIT_SECTION_NAME,(NOLOAD),) {
+		/*
+		 * This section is used for non-initialized objects that
+		 * will not be cleared during the boot process.
+		 */
+		*(.noinit)
+		*(".noinit.*")
+
+	} GROUP_LINK_IN(RAMABLE_REGION)
+
+	/* Define linker symbols */
+	_image_ram_end = .;
+	_end = .; /* end of image */
+	__bss_num_words = (__bss_end - __bss_start) >> 2;
+
+	GROUP_END(RAMABLE_REGION)
+
+	/* Data Closely Coupled Memory (DCCM) */
+	GROUP_START(DCCM)
+	GROUP_END(DCCM)
+
+	SECTION_PROLOGUE(initlevel_error, (OPTIONAL),)
+	{
+		DEVICE_INIT_UNDEFINED_SECTION()
+	}
+	ASSERT(SIZEOF(initlevel_error) == 0, "Undefined initialization levels used.")
+
+	}
+
+#ifdef CONFIG_XIP
+/*
+ * Round up number of words for DATA section to ensure that XIP copies the
+ * entire data section. XIP copy is done in words only, so there may be up
+ * to 3 extra bytes copied in next section (BSS). At run time, the XIP copy
+ * is done first followed by clearing the BSS section.
+ */
+__data_size = (__data_ram_end - __data_ram_start);
+__data_num_words = (__data_size + 3) >> 2;
+
+#endif
diff --git a/include/device.h b/include/device.h
index e02d119..30f2687 100644
--- a/include/device.h
+++ b/include/device.h
@@ -98,6 +98,9 @@ extern "C" {
  * during initialization.
  */
 
+#ifdef _WIN32
+#include "..\arch\msvc\core\device_link.h"
+#else
 #ifndef CONFIG_DEVICE_POWER_MANAGEMENT
 #define DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, data, cfg_info, \
 			    level, prio, api) \
@@ -181,6 +184,7 @@ extern struct device_pm_ops device_pm_ops_nop;
 #define DEVICE_INIT(dev_name, drv_name, init_fn, data, cfg_info, level, prio) \
 	DEVICE_AND_API_INIT(dev_name, drv_name, init_fn, data, cfg_info, \
 			    level, prio, NULL)
+#endif  // _WIN32
 
 /**
  * @def DEVICE_NAME_GET
diff --git a/include/drivers/console/uart_console.h b/include/drivers/console/uart_console.h
index ace834c..0db0b8a 100644
--- a/include/drivers/console/uart_console.h
+++ b/include/drivers/console/uart_console.h
@@ -27,7 +27,7 @@ extern "C" {
 
 #define MAX_LINE_LEN 256
 struct uart_console_input {
-	int _unused;
+	void *_unused;
 	char line[MAX_LINE_LEN];
 };
 
diff --git a/include/irq.h b/include/irq.h
index 213cc4f..6ae5493 100644
--- a/include/irq.h
+++ b/include/irq.h
@@ -22,10 +22,12 @@
 #define _IRQ_H_
 
 /* Pull in the arch-specific implementations */
+#include <stdint.h>
 #include <arch/cpu.h>
 
 #ifndef _ASMLANGUAGE
-#include <toolchain/gcc.h>
+#include <toolchain.h>
+#include <misc/util.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/include/linker-defs.h b/include/linker-defs.h
index 0310cc5..67408d3 100644
--- a/include/linker-defs.h
+++ b/include/linker-defs.h
@@ -41,6 +41,8 @@
 /* Nothing yet to include */
 #elif defined(CONFIG_NIOS2)
 /* Nothing yet to include */
+#elif defined(CONFIG_RISCV64)
+/* Nothing yet to include */
 #else
 #error Arch not supported.
 #endif
diff --git a/include/linker-tool-gcc.h b/include/linker-tool-gcc.h
index 8b1f1c2..5b3c21f 100644
--- a/include/linker-tool-gcc.h
+++ b/include/linker-tool-gcc.h
@@ -39,6 +39,8 @@
 	#endif
 #elif defined(CONFIG_NIOS2)
 	OUTPUT_FORMAT("elf32-littlenios2", "elf32-bignios2", "elf32-littlenios2")
+#elif defined(CONFIG_RISCV64)
+	OUTPUT_FORMAT("elf64-littleriscv", "elf64-littleriscv", "elf64-littleriscv")
 #else
 	#error Arch not supported.
 #endif
diff --git a/include/misc/shell.h b/include/misc/shell.h
index 3759bba..cf75ad9 100644
--- a/include/misc/shell.h
+++ b/include/misc/shell.h
@@ -15,6 +15,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#ifndef __INCLUDE_SHELL_H__
+#define __INCLUDE_SHELL_H__
 
 #ifdef __cplusplus
 extern "C" {
@@ -65,3 +67,4 @@ void shell_register_prompt_handler(shell_prompt_function_t handler);
 }
 #endif
 
+#endif  // __INCLUDE_SHELL_H__
diff --git a/include/misc/util.h b/include/misc/util.h
index 3f53ec6..0305a67 100644
--- a/include/misc/util.h
+++ b/include/misc/util.h
@@ -32,6 +32,22 @@ extern "C" {
 
 #include <stdint.h>
 
+#ifdef CONFIG_RISCV64
+#define POINTER_TO_UINT(x) ((uint64_t) (x))
+#define UINT_TO_POINTER(x) ((void *) (x))
+#define POINTER_TO_INT(x)  ((int64_t) (x))
+#define INT_TO_POINTER(x)  ((void *) (x))
+
+#define ARRAY_SIZE(array) ((uint64_t)(sizeof(array) / sizeof((array)[0])))
+#define CONTAINER_OF(ptr, type, field) \
+	((type *)(((char *)(ptr)) - offsetof(type, field)))
+
+/* round "x" up/down to next multiple of "align" (which must be a power of 2) */
+#define ROUND_UP(x, align)                                   \
+	(((uint64_t)(x) + ((uint64_t)align - 1)) & \
+	 ~((uint64_t)align - 1))
+#define ROUND_DOWN(x, align) ((uint64_t)(x) & ~((uint64_t)align - 1))
+#else
 /* Helper to pass a int as a pointer or vice-versa.
  * Those are available for 32 bits architectures:
  */
@@ -49,12 +65,15 @@ extern "C" {
 	(((unsigned long)(x) + ((unsigned long)align - 1)) & \
 	 ~((unsigned long)align - 1))
 #define ROUND_DOWN(x, align) ((unsigned long)(x) & ~((unsigned long)align - 1))
+#endif  // _WIN32/!_WIN32
 
+#if!defined INLINE
 #ifdef INLINED
 #define INLINE inline
 #else
 #define INLINE
 #endif
+#endif
 
 #ifndef max
 #define max(a, b) (((a) > (b)) ? (a) : (b))
diff --git a/include/nanokernel.h b/include/nanokernel.h
index 0135833..704437c 100644
--- a/include/nanokernel.h
+++ b/include/nanokernel.h
@@ -69,6 +69,8 @@ struct _nano_timeout {
 	struct tcs *tcs;
 	struct _nano_queue *wait_q;
 	int32_t delta_ticks_from_prev;
+	// RISC-V: to avoid "unaligned store" exception make 8-bytes alignment
+	int32_t align_to_8bytes;
 	_nano_timeout_func_t func;
 };
 /**
@@ -183,7 +185,7 @@ extern void sys_thread_busy_wait(uint32_t usec_to_wait);
  */
 extern nano_thread_id_t fiber_start(char *stack, unsigned stack_size,
 		nano_fiber_entry_t entry,
-		int arg1, int arg2, unsigned prio, unsigned options);
+		long arg1, long arg2, unsigned prio, unsigned options);
 
 /* Methods for fibers */
 
@@ -203,7 +205,7 @@ extern nano_thread_id_t fiber_start(char *stack, unsigned stack_size,
  * @return nanokernel thread identifier
  */
 extern nano_thread_id_t fiber_fiber_start(char *pStack, unsigned int stackSize,
-		nano_fiber_entry_t entry, int arg1, int arg2, unsigned prio,
+		nano_fiber_entry_t entry, long arg1, long arg2, unsigned prio,
 		unsigned options);
 
 /**
@@ -255,7 +257,7 @@ struct fiber_config {
 static inline nano_thread_id_t
 fiber_fiber_start_config(const struct fiber_config *config,
 			 nano_fiber_entry_t entry,
-			 int arg1, int arg2, unsigned options)
+			 long arg1, long arg2, unsigned options)
 {
 	return fiber_fiber_start(config->stack, config->stack_size,
 				 entry, arg1, arg2, config->prio, options);
@@ -269,7 +271,7 @@ fiber_fiber_start_config(const struct fiber_config *config,
 static inline nano_thread_id_t
 fiber_start_config(const struct fiber_config *config,
 		   nano_fiber_entry_t entry,
-		   int arg1, int arg2, unsigned options)
+		   long arg1, long arg2, unsigned options)
 {
 	return fiber_start(config->stack, config->stack_size, entry,
 			   arg1, arg2, config->prio, options);
@@ -376,14 +378,14 @@ extern void task_sleep(int32_t timeout_in_ticks);
  */
 extern nano_thread_id_t fiber_fiber_delayed_start(char *stack,
 		unsigned int stack_size_in_bytes,
-		nano_fiber_entry_t entry_point, int param1,
-		int param2, unsigned int priority,
+		nano_fiber_entry_t entry_point, long param1,
+		long param2, unsigned int priority,
 		unsigned int options, int32_t timeout_in_ticks);
 
 extern nano_thread_id_t fiber_delayed_start(char *stack,
 		unsigned int stack_size_in_bytes,
-		nano_fiber_entry_t entry_point, int param1,
-		int param2, unsigned int priority,
+		nano_fiber_entry_t entry_point, long param1,
+		long param2, unsigned int priority,
 		unsigned int options, int32_t timeout_in_ticks);
 extern void fiber_delayed_start_cancel(nano_thread_id_t handle);
 
@@ -417,7 +419,7 @@ extern void fiber_fiber_delayed_start_cancel(nano_thread_id_t handle);
  * @sa fiber_fiber_start
  */
 extern nano_thread_id_t task_fiber_start(char *pStack, unsigned int stackSize,
-		nano_fiber_entry_t entry, int arg1, int arg2, unsigned prio,
+		nano_fiber_entry_t entry, long arg1, long arg2, unsigned prio,
 		unsigned options);
 
 /**
@@ -426,7 +428,7 @@ extern nano_thread_id_t task_fiber_start(char *pStack, unsigned int stackSize,
 static inline nano_thread_id_t
 task_fiber_start_config(const struct fiber_config *config,
 			nano_fiber_entry_t entry,
-			int arg1, int arg2, unsigned options)
+			long arg1, long arg2, unsigned options)
 {
 	return task_fiber_start(config->stack, config->stack_size,
 				entry, arg1, arg2, config->prio, options);
@@ -441,8 +443,8 @@ task_fiber_start_config(const struct fiber_config *config,
  */
 extern nano_thread_id_t task_fiber_delayed_start(char *stack,
 		unsigned int stack_size_in_bytes,
-		nano_fiber_entry_t entry_point, int param1,
-		int param2, unsigned int priority,
+		nano_fiber_entry_t entry_point, long param1,
+		long param2, unsigned int priority,
 		unsigned int options, int32_t timeout_in_ticks);
 
 /**
@@ -1235,8 +1237,8 @@ extern int nano_task_sem_take(struct nano_sem *sem, int32_t timeout_in_ticks);
  */
 struct nano_stack {
 	nano_thread_id_t fiber;
-	uint32_t *base;
-	uint32_t *next;
+	uint32_t *base;         /** @warning Invalid for 64-bits architecture */
+	uint32_t *next;         /** @warning Invalid for 64-bits architecture */
 #ifdef CONFIG_DEBUG_TRACING_KERNEL_OBJECTS
 	struct nano_stack *__next;
 #endif
@@ -1700,6 +1702,13 @@ extern uint32_t sys_tick_get_32(void);
 extern uint32_t sys_cycle_get_32(void);
 
 /**
+ * @brief Return a time stamp in the high-resolution format.
+ *
+ * @return The current high-precision clock value.
+ */
+extern uint64_t sys_cycle_get_64(void);
+
+/**
  *
  * @brief Return number of ticks elapsed since a reference time.
  *
diff --git a/include/section_tags.h b/include/section_tags.h
index e1228bc..450de5a 100644
--- a/include/section_tags.h
+++ b/include/section_tags.h
@@ -26,7 +26,11 @@
 				"." _STRINGIFY(hash)				\
 				"." _STRINGIFY(line))))
 
+#ifdef _WIN32
+#define __noinit
+#else
 #define __noinit     __in_section(NOINIT,    _FILE_PATH_HASH, __COUNTER__)
+#endif
 
 #if defined(CONFIG_ARM)
 #define __scs_section  __in_section(SCS_SECTION, _FILE_PATH_HASH, __COUNTER__)
diff --git a/include/toolchain.h b/include/toolchain.h
index 37bf8f4..35a572b 100644
--- a/include/toolchain.h
+++ b/include/toolchain.h
@@ -27,6 +27,8 @@
 
 #if defined(__GNUC__) || (defined(_LINKER) && defined(__GCC_LINKER_CMD__))
 #include <toolchain/gcc.h>
+#elif defined(_WIN32)
+#include <toolchain/cl.h>
 #else
 #include <toolchain/other.h>
 #endif
diff --git a/include/toolchain/cl.h b/include/toolchain/cl.h
new file mode 100644
index 0000000..a13b518
--- /dev/null
+++ b/include/toolchain/cl.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2010-2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ * @brief MSVC toolchain abstraction
+ *
+ * Macros to abstract compiler capabilities for MSVC toolchain.
+ */
+#include <toolchain/common.h>
+
+#define FUNC_ALIAS(real_func, new_alias, return_type)
+#define _ALIAS_OF(of) __attribute__((alias(#of)))
+
+#define CODE_UNREACHABLE 
+#define FUNC_NORETURN    
+#define FUNC_NO_FP
+
+/* The GNU assembler for Cortex-M3 uses # for immediate values, not
+ * comments, so the @nobits# trick does not work.
+ */
+#if defined(CONFIG_ARM)
+#define _NODATA_SECTION(segment)  __attribute__((section(#segment)))
+#else
+#define _NODATA_SECTION(segment)				\
+	__attribute__((section(#segment ",\"wa\",@nobits#")))
+#endif
+
+/* Unaligned access */
+#define UNALIGNED_GET(p)						\
+__extension__ ({							\
+	struct  __attribute__((__packed__)) {				\
+		__typeof__(*(p)) __v;					\
+	} *__p = (__typeof__(__p)) (p);					\
+	__p->__v;							\
+})
+
+#define UNALIGNED_PUT(v, p)                                             \
+do {                                                                    \
+	struct __attribute__((__packed__)) {                            \
+		__typeof__(*p) __v;                                     \
+	} *__p = (__typeof__(__p)) (p);                                 \
+	__p->__v = (v);                                               \
+} while (0)
+
+#define _GENERIC_SECTION(segment) __attribute__((section(#segment)))
+
+#ifndef __packed
+#define __packed        __attribute__((__packed__))
+#endif
+#ifndef __aligned
+#define __aligned(x)	__attribute__((__aligned__(x)))
+#endif
+#define __may_alias     __attribute__((__may_alias__))
+#define __printf_like(f, a)   __attribute__((format (printf, f, a)))
+#define __used
+#define __deprecated	
+#define ARG_UNUSED(x) (void)(x)
+
+#define likely(x)   (x)
+#define unlikely(x) !(x)
+
diff --git a/include/toolchain/common.h b/include/toolchain/common.h
index d02d986..a8934f6 100644
--- a/include/toolchain/common.h
+++ b/include/toolchain/common.h
@@ -106,6 +106,10 @@
 
     #define PERFOPT_ALIGN .balign 4
 
+  #elif defined(CONFIG_RISCV64)
+
+    #define PERFOPT_ALIGN .balign  8
+
   #else
 
     #error Architecture unsupported
@@ -121,7 +125,9 @@
 
 /* force inlining a function */
 
-#if !defined(_ASMLANGUAGE)
+#ifdef _WIN32
+  #define ALWAYS_INLINE
+#elif !defined(_ASMLANGUAGE)
   #define ALWAYS_INLINE inline __attribute__((always_inline))
 #endif
 
@@ -130,7 +136,11 @@
 
 /* Indicate that an array will be used for stack space. */
 
+#ifdef _WIN32
+#define __stack
+#else
 #define __stack __aligned(STACK_ALIGN)
+#endif
 
 /* concatenate the values of the arguments into one */
 #define _DO_CONCAT(x, y) x ## y
diff --git a/include/toolchain/gcc.h b/include/toolchain/gcc.h
index 977ed41..1fd2038 100644
--- a/include/toolchain/gcc.h
+++ b/include/toolchain/gcc.h
@@ -281,6 +281,11 @@ A##a:
 		",%0"                              \
 		"\n\t.type\t" #name ",%%object" :  : "n"(value))
 
+#elif defined(CONFIG_RISCV64)
+
+#define GEN_ABSOLUTE_SYM(name, value) \
+	__asm__(".globl\t" #name "\n")
+
 #else
 #error processor architecture not supported
 #endif
diff --git a/kernel/nanokernel/atomic_c.c b/kernel/nanokernel/atomic_c.c
index 1a1076d..a4445cd 100644
--- a/kernel/nanokernel/atomic_c.c
+++ b/kernel/nanokernel/atomic_c.c
@@ -31,6 +31,7 @@
 #include <atomic.h>
 #include <toolchain.h>
 #include <arch/cpu.h>
+#include <irq.h>
 
 /**
  *
diff --git a/kernel/nanokernel/device.c b/kernel/nanokernel/device.c
index 61884d0..82d9ef1 100644
--- a/kernel/nanokernel/device.c
+++ b/kernel/nanokernel/device.c
@@ -20,6 +20,9 @@
 #include <misc/util.h>
 #include <atomic.h>
 
+#ifdef _WIN32
+#include <device_link.h>
+#else
 extern struct device __device_init_start[];
 extern struct device __device_PRIMARY_start[];
 extern struct device __device_SECONDARY_start[];
@@ -27,6 +30,7 @@ extern struct device __device_NANOKERNEL_start[];
 extern struct device __device_MICROKERNEL_start[];
 extern struct device __device_APPLICATION_start[];
 extern struct device __device_init_end[];
+#endif
 
 static struct device *config_levels[] = {
 	__device_PRIMARY_start,
diff --git a/kernel/nanokernel/event_logger.c b/kernel/nanokernel/event_logger.c
index 44f0876..2f17751 100644
--- a/kernel/nanokernel/event_logger.c
+++ b/kernel/nanokernel/event_logger.c
@@ -21,6 +21,7 @@
 
 #include <misc/event_logger.h>
 #include <misc/ring_buffer.h>
+#include <irq.h>
 
 void sys_event_logger_init(struct event_logger *logger,
 	uint32_t *logger_buffer, uint32_t buffer_size)
diff --git a/kernel/nanokernel/idle.c b/kernel/nanokernel/idle.c
index b5190f1..b0969d7 100644
--- a/kernel/nanokernel/idle.c
+++ b/kernel/nanokernel/idle.c
@@ -44,7 +44,9 @@ void nano_cpu_set_idle(int32_t ticks)
 {
 	extern tNANO _nanokernel;
 
+#ifdef CONFIG_ADVANCED_POWER_MANAGEMENT
 	_nanokernel.idle = ticks;
+#endif
 }
 
 #if defined(CONFIG_NANOKERNEL) && defined(CONFIG_TICKLESS_IDLE)
diff --git a/kernel/nanokernel/include/nano_internal.h b/kernel/nanokernel/include/nano_internal.h
index 6a5f7ce..f89100b 100644
--- a/kernel/nanokernel/include/nano_internal.h
+++ b/kernel/nanokernel/include/nano_internal.h
@@ -73,7 +73,7 @@ extern void _new_thread(char *pStack, unsigned stackSize,
 extern void _nano_fiber_ready(struct tcs *tcs);
 extern void _nano_fiber_swap(void);
 
-extern unsigned int _Swap(unsigned int);
+extern void *_Swap(int);
 
 /* set and clear essential fiber/task flag */
 
diff --git a/kernel/nanokernel/nano_fiber.c b/kernel/nanokernel/nano_fiber.c
index cfb2f84..586b621 100644
--- a/kernel/nanokernel/nano_fiber.c
+++ b/kernel/nanokernel/nano_fiber.c
@@ -70,8 +70,8 @@ FUNC_ALIAS(_fiber_start, fiber_start, nano_thread_id_t);
 nano_thread_id_t _fiber_start(char *pStack,
 		unsigned stackSize, /* stack size in bytes */
 		nano_fiber_entry_t pEntry,
-		int parameter1,
-		int parameter2,
+		long parameter1,
+		long parameter2,
 		unsigned priority,
 		unsigned options)
 {
@@ -186,8 +186,8 @@ FUNC_ALIAS(fiber_delayed_start, task_fiber_delayed_start, nano_thread_id_t);
 
 nano_thread_id_t fiber_delayed_start(char *stack,
 			  unsigned int stack_size_in_bytes,
-			  nano_fiber_entry_t entry_point, int param1,
-			  int param2, unsigned int priority,
+			  nano_fiber_entry_t entry_point, long param1,
+			  long param2, unsigned int priority,
 			  unsigned int options, int32_t timeout_in_ticks)
 {
 	unsigned int key;
diff --git a/kernel/nanokernel/nano_fifo.c b/kernel/nanokernel/nano_fifo.c
index 22a5ea8..3fb657f 100644
--- a/kernel/nanokernel/nano_fifo.c
+++ b/kernel/nanokernel/nano_fifo.c
@@ -133,7 +133,7 @@ void _fifo_put_non_preemptible(struct nano_fifo *fifo, void *data)
 	tcs = _nano_wait_q_remove(&fifo->wait_q);
 	if (tcs) {
 		_nano_timeout_abort(tcs);
-		fiberRtnValueSet(tcs, (unsigned int)data);
+		fiberRtnValueSet(tcs, data);
 	} else {
 		enqueue_data(fifo, data);
 		_NANO_UNPEND_TASKS(&fifo->task_q);
@@ -151,7 +151,7 @@ void nano_task_fifo_put(struct nano_fifo *fifo, void *data)
 	tcs = _nano_wait_q_remove(&fifo->wait_q);
 	if (tcs) {
 		_nano_timeout_abort(tcs);
-		fiberRtnValueSet(tcs, (unsigned int)data);
+		fiberRtnValueSet(tcs, data);
 		_Swap(key);
 		return;
 	}
@@ -192,7 +192,7 @@ void _fifo_put_list_non_preemptible(struct nano_fifo *fifo,
 
 	while (head && ((fiber = _nano_wait_q_remove(&fifo->wait_q)))) {
 		_nano_timeout_abort(fiber);
-		fiberRtnValueSet(fiber, (unsigned int)head);
+		fiberRtnValueSet(fiber, head);
 		head = *(void **)head;
 	}
 
@@ -229,7 +229,7 @@ void nano_task_fifo_put_list(struct nano_fifo *fifo, void *head, void *tail)
 	first_fiber = fifo->wait_q.head;
 	while (head && ((fiber = _nano_wait_q_remove(&fifo->wait_q)))) {
 		_nano_timeout_abort(fiber);
-		fiberRtnValueSet(fiber, (unsigned int)head);
+		fiberRtnValueSet(fiber, head);
 		head = *(void **)head;
 	}
 
diff --git a/kernel/nanokernel/nano_init.c b/kernel/nanokernel/nano_init.c
index 868093a..4478829 100644
--- a/kernel/nanokernel/nano_init.c
+++ b/kernel/nanokernel/nano_init.c
@@ -214,6 +214,7 @@ static void nano_init(struct tcs *dummyOutContext)
 
 	dummyOutContext->flags = FIBER | ESSENTIAL;
 	dummyOutContext->prio = 0;
+	dummyOutContext->intlock = 0;
 
 
 	/*
@@ -312,7 +313,7 @@ FUNC_NORETURN void _Cstart(void)
 {
 	/* floating point operations are NOT performed during nanokernel init */
 
-	char dummyTCS[__tTCS_NOFLOAT_SIZEOF];
+	char dummyTCS[sizeof(struct tcs)];
 
 	/*
 	 * Initialize nanokernel data structures. This step includes
diff --git a/kernel/nanokernel/nano_lifo.c b/kernel/nanokernel/nano_lifo.c
index d38aed5..0c52f14 100644
--- a/kernel/nanokernel/nano_lifo.c
+++ b/kernel/nanokernel/nano_lifo.c
@@ -72,7 +72,7 @@ void _lifo_put_non_preemptible(struct nano_lifo *lifo, void *data)
 	tcs = _nano_wait_q_remove(&lifo->wait_q);
 	if (tcs) {
 		_nano_timeout_abort(tcs);
-		fiberRtnValueSet(tcs, (unsigned int) data);
+		fiberRtnValueSet(tcs, data);
 	} else {
 		*(void **) data = lifo->list;
 		lifo->list = data;
@@ -91,7 +91,7 @@ void nano_task_lifo_put(struct nano_lifo *lifo, void *data)
 	tcs = _nano_wait_q_remove(&lifo->wait_q);
 	if (tcs) {
 		_nano_timeout_abort(tcs);
-		fiberRtnValueSet(tcs, (unsigned int) data);
+		fiberRtnValueSet(tcs, data);
 		_Swap(imask);
 		return;
 	}
diff --git a/kernel/nanokernel/nano_sema.c b/kernel/nanokernel/nano_sema.c
index df14eba..653b65f 100644
--- a/kernel/nanokernel/nano_sema.c
+++ b/kernel/nanokernel/nano_sema.c
@@ -64,7 +64,7 @@ FUNC_ALIAS(_sem_give_non_preemptible, nano_isr_sem_give, void);
 FUNC_ALIAS(_sem_give_non_preemptible, nano_fiber_sem_give, void);
 
 #ifdef CONFIG_NANO_TIMEOUTS
-	#define set_sem_available(tcs) fiberRtnValueSet(tcs, 1)
+	#define set_sem_available(tcs) fiberRtnValueSet(tcs, (void *)1)
 #else
 	#define set_sem_available(tcs) do { } while ((0))
 #endif
@@ -141,7 +141,7 @@ int _sem_take(struct nano_sem *sem, int32_t timeout_in_ticks)
 	if (timeout_in_ticks != TICKS_NONE) {
 		_NANO_TIMEOUT_ADD(&sem->wait_q, timeout_in_ticks);
 		_nano_wait_q_put(&sem->wait_q);
-		return _Swap(key);
+		return (int)_Swap(key);
 	}
 
 	irq_unlock(key);
diff --git a/kernel/nanokernel/nano_stack.c b/kernel/nanokernel/nano_stack.c
index 22a43f7..d55573f 100644
--- a/kernel/nanokernel/nano_stack.c
+++ b/kernel/nanokernel/nano_stack.c
@@ -78,7 +78,7 @@ void _stack_push_non_preemptible(struct nano_stack *stack, uint32_t data)
 	tcs = stack->fiber;
 	if (tcs) {
 		stack->fiber = 0;
-		fiberRtnValueSet(tcs, data);
+		fiberRtnValueSet(tcs, (void *)data);
 		_nano_fiber_ready(tcs);
 	} else {
 		*(stack->next) = data;
@@ -88,7 +88,7 @@ void _stack_push_non_preemptible(struct nano_stack *stack, uint32_t data)
 	irq_unlock(imask);
 }
 
-
+/** @warning Invalid for 64-bits architecture */
 void nano_task_stack_push(struct nano_stack *stack, uint32_t data)
 {
 	struct tcs *tcs;
@@ -99,7 +99,7 @@ void nano_task_stack_push(struct nano_stack *stack, uint32_t data)
 	tcs = stack->fiber;
 	if (tcs) {
 		stack->fiber = 0;
-		fiberRtnValueSet(tcs, data);
+		fiberRtnValueSet(tcs, (void *)data);
 		_nano_fiber_ready(tcs);
 		_Swap(imask);
 		return;
diff --git a/lib/libc/minimal/include/bits/restrict.h b/lib/libc/minimal/include/bits/restrict.h
index da876cb..85eb97b 100644
--- a/lib/libc/minimal/include/bits/restrict.h
+++ b/lib/libc/minimal/include/bits/restrict.h
@@ -28,6 +28,8 @@
 
 #ifdef __cplusplus
 	#define _Restrict __restrict__
+#elif defined (_WIN32)
+	#define _Restrict
 #else
 	#define _Restrict restrict
 #endif
diff --git a/lib/libc/minimal/include/bits/size_t.h b/lib/libc/minimal/include/bits/size_t.h
index 0ac2525..c534426 100644
--- a/lib/libc/minimal/include/bits/size_t.h
+++ b/lib/libc/minimal/include/bits/size_t.h
@@ -30,6 +30,8 @@ typedef unsigned int size_t;
 typedef unsigned int size_t;
 #elif defined(__NIOS2__)
 typedef unsigned int size_t;
+#elif defined(CONFIG_RISCV64)
+typedef unsigned long long  size_t;
 #else
 #error "The minimal libc library does not recognize the architecture!\n"
 #endif
diff --git a/lib/libc/minimal/include/stddef.h b/lib/libc/minimal/include/stddef.h
index 2e1ef66..5ff0e68 100644
--- a/lib/libc/minimal/include/stddef.h
+++ b/lib/libc/minimal/include/stddef.h
@@ -24,8 +24,12 @@
 
 #if !defined(__ptrdiff_t_defined)
 #define __ptrdiff_t_defined
+#ifdef _ARCH64
+typedef long long  ptrdiff_t;
+#else
 typedef int  ptrdiff_t;
 #endif
+#endif
 
 #define offsetof(type, member) ((size_t) (&((type *) NULL)->member))
 
diff --git a/lib/libc/minimal/include/stdint.h b/lib/libc/minimal/include/stdint.h
index 2e4deb5..4c43860 100644
--- a/lib/libc/minimal/include/stdint.h
+++ b/lib/libc/minimal/include/stdint.h
@@ -57,8 +57,13 @@ typedef unsigned short      uint16_t;
 typedef unsigned int        uint32_t;
 typedef unsigned long long  uint64_t;
 
+#ifdef _ARCH64
+typedef int64_t             intptr_t;
+typedef uint64_t            uintptr_t;
+#else
 typedef int                 intptr_t;
 typedef unsigned int        uintptr_t;
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/lib/libc/minimal/include/sys/types.h b/lib/libc/minimal/include/sys/types.h
index 25a2fec..ba2ed3c 100644
--- a/lib/libc/minimal/include/sys/types.h
+++ b/lib/libc/minimal/include/sys/types.h
@@ -28,6 +28,8 @@ typedef int ssize_t;
 typedef int ssize_t;
 #elif defined(__NIOS2__)
 typedef int ssize_t;
+#elif defined(CONFIG_RISCV64)
+typedef long long ssize_t;
 #else
 #error "The minimal libc library does not recognize the architecture!\n"
 #endif
@@ -45,6 +47,8 @@ typedef int off_t;
 typedef int off_t;
 #elif defined(__NIOS2__)
 typedef int off_t;
+#elif defined(CONFIG_RISCV64)
+typedef long long ssize_t;
 #else
 #error "The minimal libc library does not recognize the architecture!\n"
 #endif
diff --git a/lib/libc/minimal/source/stdlib/strtol.c b/lib/libc/minimal/source/stdlib/strtol.c
index 9617c2b..12b412b 100644
--- a/lib/libc/minimal/source/stdlib/strtol.c
+++ b/lib/libc/minimal/source/stdlib/strtol.c
@@ -88,7 +88,7 @@ long strtol(const char *nptr, char **endptr, register int base)
 	 * Set any if any `digits' consumed; make it negative to indicate
 	 * overflow.
 	 */
-	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
+	cutoff = neg ? (unsigned long)(-((long)LONG_MIN)) : LONG_MAX;
 	cutlim = cutoff % (unsigned long)base;
 	cutoff /= (unsigned long)base;
 	for (acc = 0, any = 0;; c = *s++) {
@@ -112,7 +112,7 @@ long strtol(const char *nptr, char **endptr, register int base)
 		acc = neg ? LONG_MIN : LONG_MAX;
 		errno = ERANGE;
 	} else if (neg)
-		acc = -acc;
+		acc = (unsigned long)(-((long)acc));
 	if (endptr != 0)
 		*endptr = (char *)(any ? s - 1 : nptr);
 	return acc;
diff --git a/lib/libc/minimal/source/stdlib/strtoul.c b/lib/libc/minimal/source/stdlib/strtoul.c
index 77610d7..4ac3eff 100644
--- a/lib/libc/minimal/source/stdlib/strtoul.c
+++ b/lib/libc/minimal/source/stdlib/strtoul.c
@@ -91,7 +91,7 @@ unsigned long strtoul(const char *nptr, char **endptr, register int base)
 		acc = ULONG_MAX;
 		errno = ERANGE;
 	} else if (neg)
-		acc = -acc;
+		acc = (unsigned long)(-((long)acc));
 	if (endptr != 0)
 		*endptr = (char *)(any ? s - 1 : nptr);
 	return acc;
diff --git a/lib/libc/minimal/source/stdout/prf.c b/lib/libc/minimal/source/stdout/prf.c
index 6e6d829..1d27057 100644
--- a/lib/libc/minimal/source/stdout/prf.c
+++ b/lib/libc/minimal/source/stdout/prf.c
@@ -69,7 +69,7 @@ static int _to_hex(char *buf, uint32_t value, int alt_form, int precision, int p
 	}
 	*buf = 0;
 
-	return buf - start;
+	return (int)(buf - start);
 }
 
 static int _to_octal(char *buf, uint32_t value, int alt_form, int precision)
@@ -101,7 +101,7 @@ static int _to_octal(char *buf, uint32_t value, int alt_form, int precision)
 	}
 	*buf = 0;
 
-	return buf - start;
+	return (int)(buf - start);
 }
 
 static int _to_udec(char *buf, uint32_t value, int precision)
@@ -128,7 +128,7 @@ static int _to_udec(char *buf, uint32_t value, int precision)
 	}
 	*buf = 0;
 
-	return buf - start;
+	return (int)(buf - start);
 }
 
 static int _to_dec(char *buf, int32_t value, int fplus, int fspace, int precision)
@@ -148,7 +148,7 @@ static int _to_dec(char *buf, int32_t value, int fplus, int fspace, int precisio
 	else if (fspace)
 		*buf++ = ' ';
 
-	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
+	return (int)((buf + _to_udec(buf, (uint32_t) value, precision)) - start);
 }
 
 static void _llshift(uint32_t value[])
@@ -334,7 +334,7 @@ static int _to_float(char *buf, uint32_t double_temp[], int full, int c,
 			*buf++ = 'N';
 		}
 		*buf = 0;
-		return buf - start;
+		return (int)(buf - start);
 	}
 
 	if ((exp | fract[1] | fract[0]) != 0) {
@@ -484,7 +484,7 @@ static int _to_float(char *buf, uint32_t double_temp[], int full, int c,
 	}
 	*buf = 0;
 
-	return buf - start;
+	return (int)(buf - start);
 }
 
 static int _atoi(char **sptr)
diff --git a/lib/libc/minimal/source/string/string.c b/lib/libc/minimal/source/string/string.c
index 7a18e1a..73c4595 100644
--- a/lib/libc/minimal/source/string/string.c
+++ b/lib/libc/minimal/source/string/string.c
@@ -16,6 +16,7 @@
  * limitations under the License.
  */
 
+#include <bits/size_t.h>
 #include <string.h>
 
 /**
@@ -192,7 +193,7 @@ void *memmove(void *d, const void *s, size_t n)
 	char *dest = d;
 	const char *src  = s;
 
-	if ((size_t) (d - s) < n) {
+	if ((size_t) ((char *)d - (char *)s) < n) {
 		/*
 		 * The <src> buffer overlaps with the start of the <dest> buffer.
 		 * Copy backwards to prevent the premature corruption of <src>.
@@ -229,11 +230,11 @@ void *memcpy(void *_Restrict d, const void *_Restrict s, size_t n)
 	unsigned char *d_byte = (unsigned char *)d;
 	const unsigned char *s_byte = (const unsigned char *)s;
 
-	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
+	if ((((size_t)d ^ (size_t)s_byte) & 0x3) == 0) {
 
 		/* do byte-sized copying until word-aligned or finished */
 
-		while (((unsigned int)d_byte) & 0x3) {
+		while (((size_t)d_byte) & 0x3) {
 			if (n == 0) {
 				return d;
 			}
@@ -279,7 +280,7 @@ void *memset(void *buf, int c, size_t n)
 	unsigned char *d_byte = (unsigned char *)buf;
 	unsigned char c_byte = (unsigned char)c;
 
-	while (((unsigned int)d_byte) & 0x3) {
+	while (((size_t)d_byte) & 0x3) {
 		if (n == 0) {
 			return buf;
 		}
diff --git a/samples/shell/src/Makefile b/samples/shell/src/Makefile
index b666967..8f9e7e9 100644
--- a/samples/shell/src/Makefile
+++ b/samples/shell/src/Makefile
@@ -1 +1 @@
-obj-y += main.o
+obj-y += main.o dhry_1.o dhry_2.o
diff --git a/samples/shell/src/dhry.h b/samples/shell/src/dhry.h
new file mode 100644
index 0000000..5ff61aa
--- /dev/null
+++ b/samples/shell/src/dhry.h
@@ -0,0 +1,432 @@
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *                                                                            
+ *  Version:    C, Version 2.1
+ *                                                                            
+ *  File:       dhry.h (part 1 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *                      Siemens AG, E STE 35
+ *                      Postfach 3240
+ *                      8520 Erlangen
+ *                      Germany (West)
+ *                              Phone:  [xxx-49]-9131-7-20330
+ *                                      (8-17 Central European Time)
+ *                              Usenet: ..!mcvax!unido!estevax!weicker
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the
+ *      compiler; Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ *  History:    This version C/2.1 has been made for two reasons:
+ *
+ *              1) There is an obvious need for a common C version of
+ *              Dhrystone, since C is at present the most popular system
+ *              programming language for the class of processors
+ *              (microcomputers, minicomputers) where Dhrystone is used most.
+ *              There should be, as far as possible, only one C version of
+ *              Dhrystone such that results can be compared without
+ *              restrictions. In the past, the C versions distributed
+ *              by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *              had small (though not significant) differences.
+ *
+ *              2) As far as it is possible without changes to the Dhrystone
+ *              statistics, optimizing compilers should be prevented from
+ *              removing significant statements.
+ *
+ *              This C version has been developed in cooperation with
+ *              Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *              ideas from the "Version 1.1" distributed previously by
+ *              him over the UNIX network Usenet.
+ *              I also thank Chaim Benedelac (National Semiconductor),
+ *              David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *              for their help with comments on earlier versions of the
+ *              benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *              Rick Richardson's version distributed via Usenet, not the
+ *              version distributed earlier via floppy disk by Reinhold Weicker.
+ *              As a concession to older compilers, names have been made
+ *              unique within the first 8 characters.
+ *              Inside the measurement loop, this version follows the
+ *              version previously distributed by Reinhold Weicker.
+ *
+ *              At several places in the benchmark, code has been added,
+ *              but within the measurement loop only in branches that 
+ *              are not executed. The intention is that optimizing compilers
+ *              should be prevented from moving code out of the measurement
+ *              loop, or from removing code altogether. Since the statements
+ *              that are executed within the measurement loop have NOT been
+ *              changed, the numbers defining the "Dhrystone distribution"
+ *              (distribution of statements, operand types and locality)
+ *              still hold. Except for sophisticated optimizing compilers,
+ *              execution times for this version should be the same as
+ *              for previous versions.
+ *              
+ *              Since it has proven difficult to subtract the time for the
+ *              measurement loop overhead in a correct way, the loop check
+ *              has been made a part of the benchmark. This does have
+ *              an impact - though a very minor one - on the distribution
+ *              statistics which have been updated for this version.
+ *
+ *              All changes within the measurement loop are described
+ *              and discussed in the companion paper "Rationale for
+ *              Dhrystone version 2".
+ *
+ *              Because of the self-imposed limitation that the order and
+ *              distribution of the executed statements should not be
+ *              changed, there are still cases where optimizing compilers
+ *              may not generate code for some statements. To a certain
+ *              degree, this is unavoidable for small synthetic benchmarks.
+ *              Users of the benchmark are advised to check code listings
+ *              whether code is generated for all statements of Dhrystone.
+ *
+ *              Version 2.1 is identical to version 2.0 distributed via
+ *              the UNIX network Usenet in March 1988 except that it corrects
+ *              some minor deficiencies that were found by users of version 2.0.
+ *              The only change within the measurement loop is that a
+ *              non-executed "else" part was added to the "if" statement in
+ *              Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *              -DREG=register          (default: Not defined)
+ *                      As an approximation to what an average C programmer
+ *                      might do, the "register" storage class is applied
+ *                      (if enabled by -DREG=register)
+ *                      - for local variables, if they are used (dynamically)
+ *                        five or more times
+ *                      - for parameters if they are used (dynamically)
+ *                        six or more times
+ *                      Note that an optimal "register" strategy is
+ *                      compiler-dependent, and that "register" declarations
+ *                      do not necessarily lead to faster execution.
+ *              -DNOSTRUCTASSIGN        (default: Not defined)
+ *                      Define if the C compiler does not support
+ *                      assignment of structures.
+ *              -DNOENUMS               (default: Not defined)
+ *                      Define if the C compiler does not support
+ *                      enumeration types.
+ *              -DTIMES                 (default)
+ *              -DTIME
+ *                      The "times" function of UNIX (returning process times)
+ *                      or the "time" function (returning wallclock time)
+ *                      is used for measurement. 
+ *                      For single user machines, "time ()" is adequate. For
+ *                      multi-user machines where you cannot get single-user
+ *                      access, use the "times ()" function. If you have
+ *                      neither, use a stopwatch in the dead of night.
+ *                      "printf"s are provided marking the points "Start Timer"
+ *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *                      command, as this will measure the total time to
+ *                      run this program, which will (erroneously) include
+ *                      the time to allocate storage (malloc) and to perform
+ *                      the initialization.
+ *              -DHZ=nnn
+ *                      In Berkeley UNIX, the function "times" returns process
+ *                      time in 1/HZ seconds, with HZ = 60 for most systems.
+ *                      CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *                      A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  This C version of Dhrystone consists of three files:
+ *  - dhry.h (this file, containing global definitions and comments)
+ *  - dhry_1.c (containing the code corresponding to Ada package Pack_1)
+ *  - dhry_2.c (containing the code corresponding to Ada package Pack_2)
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values aX *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+
+#ifndef TIME
+#undef TIMES
+#define TIMES
+#endif
+                /* Use times(2) time function unless    */
+                /* explicitly defined otherwise         */
+
+#ifdef MSC_CLOCK
+#undef HZ
+#undef TIMES
+#include <time.h>
+#define HZ	CLK_TCK
+#endif
+		/* Use Microsoft C hi-res clock */
+
+#ifdef TIMES
+#include <sys/types.h>
+#if!defined(CONFIG_RISCV64)
+#include <sys/times.h>
+#endif
+#endif
+
+#define Mic_secs_Per_Second     1000000ll
+                /* Berkeley UNIX C returns process times in seconds/HZ */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#define true  1
+#define false 0
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+
diff --git a/samples/shell/src/dhry_1.c b/samples/shell/src/dhry_1.c
new file mode 100644
index 0000000..ee22eb4
--- /dev/null
+++ b/samples/shell/src/dhry_1.c
@@ -0,0 +1,459 @@
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *
+ *  Version:    C, Version 2.1
+ *
+ *  File:       dhry_1.c (part 2 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *
+ ****************************************************************************
+ */
+
+#include "dhry.h"
+#ifdef CONFIG_RISCV64
+#include <zephyr.h>
+#include <string.h>
+char _Next_Glob [sizeof (Rec_Type)];
+char _Glob[sizeof (Rec_Type)];
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wimplicit-function-declaration"
+#pragma GCC diagnostic ignored "-Wimplicit-int"
+#pragma GCC diagnostic ignored "-Wreturn-type"
+#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
+#endif
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+//extern char     *malloc ();
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#endif
+
+/* variables for time measurement: */
+
+#ifdef TIMES
+#ifdef CONFIG_RISCV64
+#define HZ 60000000  // 60 MHz
+int clock() {
+    return (int)sys_cycle_get_64();
+}
+#define Too_Small_Time (2)
+
+#else
+struct tms      time_info;
+extern clock_t times_ (struct tms *t);
+/* see library function "times" */
+#define Too_Small_Time (2*HZ)
+#endif
+                /* Measurements should last at least about 2 seconds */
+#endif
+#ifdef TIME
+extern long     time();
+                /* see library function "time"  */
+#define Too_Small_Time 2
+                /* Measurements should last at least 2 seconds */
+#endif
+#ifdef MSC_CLOCK
+extern clock_t	clock();
+#define Too_Small_Time (2*HZ)
+#endif
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+#ifdef CONFIG_RISCV64
+uint64_t        Microseconds,
+                Dhrystones_Per_Second;
+#else
+float           Microseconds,
+                Dhrystones_Per_Second;
+#endif
+
+/* end of variables for time measurement */
+
+#ifdef CONFIG_RISCV64
+int benchmark_dhrystone(int argc, char *argv[])
+#else
+main ()
+#endif
+/*****/
+
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Initializations */
+
+#ifdef CONFIG_RISCV64
+  Next_Ptr_Glob = (Rec_Pointer) &_Next_Glob;
+  Ptr_Glob = (Rec_Pointer) &_Glob ;
+#else
+  Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+#endif
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp,
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  printf ("\n");
+  printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
+  printf ("\n");
+  if (Reg)
+  {
+    printf ("Program compiled with 'register' attribute\n");
+    printf ("\n");
+  }
+  else
+  {
+    printf ("Program compiled without 'register' attribute\n");
+    printf ("\n");
+  }
+#ifdef CONFIG_RISCV64
+  Number_Of_Runs = 16*1024;
+#else
+  printf ("Please give the number of runs through the benchmark: ");
+  {
+    int n;
+    scanf ("%d", &n);
+    Number_Of_Runs = n;
+  }
+  printf ("\n");
+#endif
+
+  printf ("Execution starts, %d runs through Dhrystone\n", Number_Of_Runs);
+
+  /***************/
+  /* Start timer */
+  /***************/
+
+#ifdef TIMES
+#ifdef CONFIG_RISCV64
+  Begin_Time = (long) clock();
+#else
+  times (&time_info);
+  Begin_Time = (long) time_info.tms_utime;
+#endif
+#endif
+#ifdef TIME
+  Begin_Time = time ( (long *) 0);
+#endif
+#ifdef MSC_CLOCK
+  Begin_Time = clock();
+#endif
+
+  for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+  {
+
+    Proc_5();
+    Proc_4();
+      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+    Int_1_Loc = 2;
+    Int_2_Loc = 3;
+    strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+    Enum_Loc = Ident_2;
+    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+      /* Bool_Glob == 1 */
+    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+    {
+      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+        /* Int_3_Loc == 7 */
+      Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+        /* Int_3_Loc == 7 */
+      Int_1_Loc += 1;
+    } /* while */
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+      /* Int_Glob == 5 */
+    Proc_1 (Ptr_Glob);
+    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+                             /* loop body executed twice */
+    {
+      if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+          /* then, not executed */
+        {
+        Proc_6 (Ident_1, &Enum_Loc);
+        strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+        Int_2_Loc = Run_Index;
+        Int_Glob = Run_Index;
+        }
+    }
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Int_2_Loc = Int_2_Loc * Int_1_Loc;
+    Int_1_Loc = Int_2_Loc / Int_3_Loc;
+    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+    Proc_2 (&Int_1_Loc);
+      /* Int_1_Loc == 5 */
+
+  } /* loop "for Run_Index" */
+
+  /**************/
+  /* Stop timer */
+  /**************/
+
+#ifdef TIMES
+#ifdef CONFIG_RISCV64
+  End_Time = (long) clock();
+#else
+  times_ (&time_info);
+  End_Time = (long) time_info.tms_utime;
+#endif
+#endif
+#ifdef TIME
+  End_Time = time ( (long *) 0);
+#endif
+#ifdef MSC_CLOCK
+  End_Time = clock();
+#endif
+
+  printf ("Execution ends\n");
+  printf ("\n");
+  printf ("Final values of the variables used in the benchmark:\n");
+  printf ("\n");
+  printf ("Int_Glob:            %d\n", Int_Glob);
+  printf ("        should be:   %d\n", 5);
+  printf ("Bool_Glob:           %d\n", Bool_Glob);
+  printf ("        should be:   %d\n", 1);
+  printf ("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  printf ("        should be:   %c\n", 'A');
+  printf ("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  printf ("        should be:   %c\n", 'B');
+  printf ("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  printf ("        should be:   %d\n", 7);
+  printf ("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  printf ("        should be:   Number_Of_Runs + 10\n");
+  printf ("Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", (int) Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent)\n");
+  printf ("  Discr:             %d\n", Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 2);
+  printf ("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 17);
+  printf ("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Next_Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", (int) Next_Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent), same as above\n");
+  printf ("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 1);
+  printf ("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 18);
+  printf ("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Int_1_Loc:           %d\n", Int_1_Loc);
+  printf ("        should be:   %d\n", 5);
+  printf ("Int_2_Loc:           %d\n", Int_2_Loc);
+  printf ("        should be:   %d\n", 13);
+  printf ("Int_3_Loc:           %d\n", Int_3_Loc);
+  printf ("        should be:   %d\n", 7);
+  printf ("Enum_Loc:            %d\n", Enum_Loc);
+  printf ("        should be:   %d\n", 1);
+  printf ("Str_1_Loc:           %s\n", Str_1_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  printf ("Str_2_Loc:           %s\n", Str_2_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  printf ("\n");
+
+  User_Time = End_Time - Begin_Time;
+
+  if (User_Time < Too_Small_Time)
+  {
+    printf ("Measured time too small to obtain meaningful results\n");
+    printf ("Please increase number of runs\n");
+    printf ("\n");
+  }
+  else
+  {
+
+#ifdef TIME
+    Microseconds = (float) User_Time * Mic_secs_Per_Second
+                        / (float) Number_Of_Runs;
+    Dhrystones_Per_Second = (float) Number_Of_Runs / (float) User_Time;
+#elif defined(CONFIG_RISCV64)
+#else
+    Microseconds = (float) User_Time * Mic_secs_Per_Second
+                        / ((float) HZ * ((float) Number_Of_Runs));
+    Dhrystones_Per_Second = ((float) HZ * (float) Number_Of_Runs)
+                        / (float) User_Time;
+#endif
+    printf ("Microseconds for one run through Dhrystone: ");
+#ifdef CONFIG_RISCV64
+    int64_t div1 = (int64_t)HZ*(int64_t)Number_Of_Runs;
+    Microseconds = 10ll * (int64_t)User_Time * Mic_secs_Per_Second;
+    printf ("%6d.%01d \n", (int)(Microseconds/(10*div1)), (int)(Microseconds%10));
+#else
+    printf ("%6.1f \n", Microseconds);
+#endif
+    printf ("Dhrystones per Second:                      ");
+#ifdef CONFIG_RISCV64
+    Dhrystones_Per_Second = 10ll * ((int64_t)HZ * (int64_t) Number_Of_Runs);
+    div1 = (int64_t)User_Time;
+    printf ("%6d.%01d \n", (int)(Dhrystones_Per_Second/(10*div1)), (int)(Dhrystones_Per_Second%10));
+#else
+    printf ("%6.1f \n", Dhrystones_Per_Second);
+#endif
+    printf ("\n");
+
+  }
+
+  return 0;
+}
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob);
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10,
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+
+        /* Procedure for the assignment of structures,          */
+        /* if the C compiler doesn't support this feature       */
+#ifdef  NOSTRUCTASSIGN
+memcpy (d, s, l)
+register char   *d;
+register char   *s;
+register int    l;
+{
+        while (l--) *d++ = *s++;
+}
+#endif
+
+#ifdef CONFIG_RISCV64
+#pragma GCC diagnostic pop
+#endif
diff --git a/samples/shell/src/dhry_2.c b/samples/shell/src/dhry_2.c
new file mode 100644
index 0000000..8ab9fd0
--- /dev/null
+++ b/samples/shell/src/dhry_2.c
@@ -0,0 +1,202 @@
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *
+ *  Version:    C, Version 2.1
+ *
+ *  File:       dhry_2.c (part 3 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *
+ ****************************************************************************
+ */
+
+#include "dhry.h"
+
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#endif
+
+#ifdef CONFIG_RISCV64
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wimplicit-function-declaration"
+#pragma GCC diagnostic ignored "-Wimplicit-int"
+#pragma GCC diagnostic ignored "-Wreturn-type"
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1:
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2:
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5:
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+#ifdef CONFIG_RISCV64
+#pragma GCC diagnostic pop
+#endif
diff --git a/samples/shell/src/main.c b/samples/shell/src/main.c
index 9ed8032..c8fbf6a 100644
--- a/samples/shell/src/main.c
+++ b/samples/shell/src/main.c
@@ -17,8 +17,11 @@
 #include <zephyr.h>
 #include <misc/printk.h>
 #include <misc/shell.h>
+#include <soc.h>
 #define DEVICE_NAME "test shell"
 
+extern int benchmark_dhrystone(int argc, char *argv[]);
+
 static int shell_cmd_ping(int argc, char *argv[])
 {
 	printk("pong\n");
@@ -35,16 +38,35 @@ static int shell_cmd_ticks(int argc, char *argv[])
 
 static int shell_cmd_highticks(int argc, char *argv[])
 {
+#ifdef CONFIG_RISCV64
+	printk("highticks: %x\n", sys_cycle_get_64());
+#else
 	printk("highticks: %u\n", sys_cycle_get_32());
+#endif
 
 	return 0;
 }
 
+/**
+ * Output SOC plug'n'Play information with detected devices
+ */
+static int shell_cmd_pnp(int argc, char *argv[])
+{
+#ifdef CONFIG_RISCV64
+    soc_print_pnp();
+#else
+    printk("pnp not available\n");
+#endif
+    return 0;
+}
+
 
 const struct shell_cmd commands[] = {
 	{ "ping", shell_cmd_ping },
 	{ "ticks", shell_cmd_ticks },
 	{ "highticks", shell_cmd_highticks },
+	{ "pnp", shell_cmd_pnp },
+	{ "dhry", benchmark_dhrystone},
 	{ NULL, NULL }
 };
 
diff --git a/scripts/gen_offset_header/Makefile b/scripts/gen_offset_header/Makefile
index 8e6f3b3..9458eb8 100644
--- a/scripts/gen_offset_header/Makefile
+++ b/scripts/gen_offset_header/Makefile
@@ -1,4 +1,7 @@
 HOSTCFLAGS_gen_offset_header.o += -DKERNEL_VERSION=0 -Wall -Werror -g
+ifeq ($(ARCH),riscv64)
+HOSTCFLAGS_gen_offset_header.o += -DARCH_64BITS
+endif
 HOSTCFLAGS_gen_idt.o += -Wno-unused-result
 
 hostprogs-y	+= gen_offset_header
diff --git a/scripts/gen_offset_header/elf.h b/scripts/gen_offset_header/elf.h
index 449e6ad..da86c85 100644
--- a/scripts/gen_offset_header/elf.h
+++ b/scripts/gen_offset_header/elf.h
@@ -28,9 +28,16 @@
 extern "C" {
 #endif
 
+#ifdef ARCH_64BITS
+#include <inttypes.h>
+typedef uint64_t   Elf32_Addr;
+typedef uint64_t   Elf32_Off;
+typedef uint64_t   Elf32_DWord;
+#else
 typedef unsigned int    Elf32_Addr;
-typedef unsigned short  Elf32_Half;
 typedef unsigned int    Elf32_Off;
+#endif
+typedef unsigned short  Elf32_Half;
 typedef int             Elf32_Sword;
 typedef unsigned int    Elf32_Word;
 
@@ -168,14 +175,26 @@ typedef struct
 	{
 	Elf32_Word	sh_name;
 	Elf32_Word	sh_type;	/* SHT_... */
+#ifdef ARCH_64BITS
+	Elf32_DWord	sh_flags;	/* SHF_... */
+	Elf32_Addr	sh_addr;
+	Elf32_Off	sh_offset;
+	Elf32_DWord	sh_size;
+#else
 	Elf32_Word	sh_flags;	/* SHF_... */
 	Elf32_Addr	sh_addr;
 	Elf32_Off	sh_offset;
 	Elf32_Word	sh_size;
+#endif
 	Elf32_Word	sh_link;
 	Elf32_Word	sh_info;
+#ifdef ARCH_64BITS
+	Elf32_DWord	sh_addralign;
+	Elf32_DWord	sh_entsize;
+#else
 	Elf32_Word	sh_addralign;
 	Elf32_Word	sh_entsize;
+#endif
 } Elf32_Shdr;
 
 #define SHDRSZ sizeof(Elf32_Shdr)
@@ -228,11 +247,19 @@ typedef struct
 typedef struct
 	{
 	Elf32_Word	st_name;
+#ifdef ARCH_64BITS
+	unsigned char	st_info;
+	unsigned char	st_other;
+	Elf32_Half	st_shndx;
+	Elf32_Addr	st_value;
+	Elf32_DWord	st_size;
+#else
 	Elf32_Addr	st_value;
 	Elf32_Word	st_size;
 	unsigned char	st_info;
 	unsigned char	st_other;
 	Elf32_Half	st_shndx;
+#endif
 	} Elf32_Sym;
 
 #define STN_UNDEF	0
@@ -300,10 +327,17 @@ typedef struct
 	Elf32_Off	p_offset;
 	Elf32_Addr	p_vaddr;
 	Elf32_Addr	p_paddr;
+#ifdef ARCH_64BITS
+	Elf32_DWord	p_filesz;
+	Elf32_DWord	p_memsz;
+	Elf32_DWord	p_flags;
+	Elf32_DWord	p_align;
+#else
 	Elf32_Word	p_filesz;
 	Elf32_Word	p_memsz;
 	Elf32_Word	p_flags;
 	Elf32_Word	p_align;
+#endif
 	} Elf32_Phdr;
 
 #define PHDRSZ sizeof(Elf32_Phdr)
diff --git a/scripts/gen_offset_header/gen_offset_header.c b/scripts/gen_offset_header/gen_offset_header.c
index 1ed29ce..0bd49b5 100644
--- a/scripts/gen_offset_header/gen_offset_header.c
+++ b/scripts/gen_offset_header/gen_offset_header.c
@@ -260,12 +260,19 @@ static int ehdrLoad(int fd)
 	}
 
 	/* 64-bit ELF module not supported (for now) */
-
+#ifdef ARCH_64BITS
+	if (ehdr.e_ident[EI_CLASS] != ELFCLASS64)
+	{
+		fprintf(stderr, "ELF32 class not supported\n");
+		return -1;
+	}
+#else
 	if (ehdr.e_ident[EI_CLASS] != ELFCLASS32)
 	{
 		fprintf(stderr, "ELF64 class not supported\n");
 		return -1;
 	}
+#endif
 
 	/*
 	 * Dynamically determine the endianess of the host (in the absence of
@@ -343,7 +350,7 @@ static int shdrsLoad(int fd)
  * @param pSymTblSize ptr to symbol table size
  * @returns 0 if found, -1 if not
  */
-static int symTblFind(unsigned *pSymTblOffset, unsigned *pSymTblSize)
+static int symTblFind(Elf32_Off *pSymTblOffset, unsigned *pSymTblSize)
 {
 	unsigned  ix;    /* loop index */
 
@@ -536,8 +543,13 @@ static void headerAbsoluteSymbolsDump(int fd, FILE *fp, Elf32_Off symTblOffset,
 					(strstr(&pStringTable[aSym.st_name],
 						 STRUCT_SIZ_SUFFIX) != NULL))
 			{
+#ifdef ARCH_64BITS
+				fprintf(fp, "#define\t%s\t0x%" PRIx64 "\n",
+						&pStringTable[aSym.st_name], aSym.st_value);
+#else
 				fprintf(fp, "#define\t%s\t0x%X\n",
 						&pStringTable[aSym.st_name], aSym.st_value);
+#endif
 			}
 		}
 	}
diff --git a/scripts/merge_config.sh b/scripts/merge_config.sh
new file mode 100644
index 0000000..ab7be9d
--- /dev/null
+++ b/scripts/merge_config.sh
@@ -0,0 +1,172 @@
+#!/bin/sh
+#  merge_config.sh - Takes a list of config fragment values, and merges
+#  them one by one. Provides warnings on overridden values, and specified
+#  values that did not make it to the resulting .config file (due to missed
+#  dependencies or config symbol removal).
+#
+#  Portions reused from kconf_check and generate_cfg:
+#  http://git.yoctoproject.org/cgit/cgit.cgi/yocto-kernel-tools/tree/tools/kconf_check
+#  http://git.yoctoproject.org/cgit/cgit.cgi/yocto-kernel-tools/tree/tools/generate_cfg
+#
+#  Copyright (c) 2009-2010 Wind River Systems, Inc.
+#  Copyright 2011 Linaro
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License version 2 as
+#  published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#  See the GNU General Public License for more details.
+
+clean_up() {
+	rm -f $TMP_FILE
+	exit
+}
+
+trap clean_up HUP INT TERM
+
+usage() {
+	echo "Usage: $0 [OPTIONS] [CONFIG [...]]"
+	echo "  -h    display this help text"
+	echo "  -m    only merge the fragments, do not execute the make command"
+	echo "  -n    use allnoconfig instead of alldefconfig"
+	echo "  -r    list redundant entries when merging fragments"
+	echo "  -O    dir to put generated output files"
+}
+
+RUNMAKE=true
+ECHO=echo
+ALLTARGET=alldefconfig
+WARNREDUN=false
+OUTPUT=.
+
+while true; do
+	case $1 in
+	"-n")
+		ALLTARGET=allnoconfig
+		shift
+		continue
+		;;
+	"-q")
+		ECHO=false
+		shift
+		continue
+		;;
+	"-m")
+		RUNMAKE=false
+		shift
+		continue
+		;;
+	"-h")
+		usage
+		exit
+		;;
+	"-r")
+		WARNREDUN=true
+		shift
+		continue
+		;;
+	"-O")
+		if [ -d $2 ];then
+			OUTPUT=$(echo $2 | sed 's/\/*$//')
+		else
+			echo "output directory $2 does not exist" 1>&2
+			exit 1
+		fi
+		shift 2
+		continue
+		;;
+	*)
+		break
+		;;
+	esac
+done
+
+if [ "$#" -lt 2 ] ; then
+	usage
+	exit
+fi
+
+INITFILE=$1
+shift;
+
+if [ ! -r "$INITFILE" ]; then
+	echo "The base file '$INITFILE' does not exist.  Exit." >&2
+	exit 1
+fi
+
+MERGE_LIST=$*
+SED_CONFIG_EXP="s/^\(# \)\{0,1\}\(CONFIG_[a-zA-Z0-9_]*\)[= ].*/\2/p"
+TMP_FILE=$(mktemp ./.tmp.config.XXXXXXXXXX)
+
+echo "Using $INITFILE as base"
+cat $INITFILE > $TMP_FILE
+
+# Merge files, printing warnings on overridden values
+for MERGE_FILE in $MERGE_LIST ; do
+	echo "Merging $MERGE_FILE"
+	if [ ! -r "$MERGE_FILE" ]; then
+		echo "The merge file '$MERGE_FILE' does not exist.  Exit." >&2
+		exit 1
+	fi
+	CFG_LIST=$(sed -n "$SED_CONFIG_EXP" $MERGE_FILE)
+
+	for CFG in $CFG_LIST ; do
+		grep -q -w $CFG $TMP_FILE
+		if [ $? -eq 0 ] ; then
+			PREV_VAL=$(grep -w $CFG $TMP_FILE)
+			NEW_VAL=$(grep -w $CFG $MERGE_FILE)
+			if [ "x$PREV_VAL" != "x$NEW_VAL" ] ; then
+			$ECHO Value of $CFG is redefined by fragment $MERGE_FILE:
+			$ECHO Previous  value: $PREV_VAL
+			$ECHO New value:       $NEW_VAL
+			$ECHO
+			elif [ "$WARNREDUN" = "true" ]; then
+			$ECHO Value of $CFG is redundant by fragment $MERGE_FILE:
+			fi
+			sed -i.bak "/$CFG[ =]/d" $TMP_FILE
+			rm $TMP_FILE.bak
+		fi
+	done
+	cat $MERGE_FILE >> $TMP_FILE
+done
+
+if [ "$RUNMAKE" = "false" ]; then
+	cp $TMP_FILE $OUTPUT/.config
+	$ECHO "#"
+	$ECHO "# merged configuration written to $OUTPUT/.config (needs make)"
+	$ECHO "#"
+	clean_up
+	exit
+fi
+
+# If we have an output dir, setup the O= argument, otherwise leave
+# it blank, since O=. will create an unnecessary ./source softlink
+OUTPUT_ARG=""
+if [ "$OUTPUT" != "." ] ; then
+	OUTPUT_ARG="O=$OUTPUT"
+fi
+
+
+# Use the merged file as the starting point for:
+# alldefconfig: Fills in any missing symbols with Kconfig default
+# allnoconfig: Fills in any missing symbols with # CONFIG_* is not set
+make KCONFIG_ALLCONFIG=$TMP_FILE $OUTPUT_ARG $ALLTARGET
+
+
+# Check all specified config values took (might have missed-dependency issues)
+for CFG in $(sed -n "$SED_CONFIG_EXP" $TMP_FILE); do
+
+	REQUESTED_VAL=$(grep -w -e "$CFG" $TMP_FILE)
+	ACTUAL_VAL=$(grep -w -e "$CFG" $OUTPUT/.config)
+	if [ "x$REQUESTED_VAL" != "x$ACTUAL_VAL" ] ; then
+		$ECHO "Value requested for $CFG not in final .config"
+		$ECHO "Requested value:  $REQUESTED_VAL"
+		$ECHO "Actual value:     $ACTUAL_VAL"
+		$ECHO ""
+	fi
+done
+
+clean_up
diff --git a/scripts/sanity_chk/arches/riscv64.ini b/scripts/sanity_chk/arches/riscv64.ini
new file mode 100644
index 0000000..118d26a
--- /dev/null
+++ b/scripts/sanity_chk/arches/riscv64.ini
@@ -0,0 +1,6 @@
+[arch]
+name = riscv64
+platforms = riscv_gnss
+
+[riscv_gnss]
+qemu_support = false
