<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RISC-V VHDL: System-on-Chip: Debug Support Unit (DSU)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="fixed_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RISC-V VHDL: System-on-Chip
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('periphery_page_1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Debug Support Unit (DSU) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="dsu_overview"></a>
Overview</h1>
<p>Debug Support Unit (DSU) was developed to interact with "RIVER" CPU via its debug port interace. This bus provides access to all internal CPU registers and states and may be additionally extended by request. Run control functionality like 'run', 'halt', 'step' or 'breakpoints' imlemented using proprietary algorithms and intend to simplify integration with debugger application.</p>
<p>Set of general registers and control registers (CSR) are described in RISC-V privileged ISA specification and also available for read and write access via debug port.</p>
<dl class="section note"><dt>Note</dt><dd>Take into account that CPU can have any number of platform specific CSRs that usually not entirely documented.</dd></dl>
<h1><a class="anchor" id="dsu_regs"></a>
DSU registers mapping</h1>
<p>DSU acts like a slave AMBA AXI4 device that is directly mapped into physical memory. Default address location for our implementation is 0x80020000. DSU directly transforms device offset address into one of regions of the debug port: </p><ul>
<li>
<b>0x00000..0x08000 (Region 1):</b> CSR registers. </li>
<li>
<b>0x08000..0x10000 (Region 2):</b> General set of registers. </li>
<li>
<b>0x10000..0x18000 (Region 3):</b> Run control and debug support registers. </li>
<li>
<b>0x18000..0x20000 (Region 4):</b> Local DSU region that doesn't access CPU debug port. </li>
</ul>
<dl class="section user"><dt>Example:</dt><dd>Bus transaction at address <em>0x80023C10</em> will be redirected to Debug port with CSR index <em>0x782</em>.</dd></dl>
<h2><a class="anchor" id="dsu_csr"></a>
CSR Region (32 KB)</h2>
<dl class="section user"><dt>User Exception Program Counter (0x00208). ISA offset 0x041.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Name </th><th>Definition  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">uepc </td><td><b>User mode exception program counter</b>. Instruction URET is used to return from traps in User Mode into specified instruction pointer. URET is only provided if user-mode traps are supported. </td></tr>
</table>
<dl class="section user"><dt>Machine Status Register (0x01800). ISA offset 0x300.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">SD </td><td align="center">63 </td><td align="left">Bit summarizes whether either the FS field or XS field signals the presence of some dirty state that will require saving extended user context to memory </td></tr>
<tr>
<td align="center">22 </td><td align="center">RW </td><td align="center">22h'0 </td><td align="left">WPRI </td><td align="center">62:20 </td><td align="left">Reserved </td></tr>
<tr>
<td align="center">5 </td><td align="center">RW </td><td align="center">5h'0 </td><td align="left">VM (WARL)</td><td align="center">28:24 </td><td align="left">Virtual addressing enable </td></tr>
<tr>
<td align="center">4 </td><td align="center">RW </td><td align="center">4h'0 </td><td align="left">WPRI </td><td align="center">23:20 </td><td align="left">Reserved </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">MXR </td><td align="center">19 </td><td align="left"><b>Make eXecutable Readable</b> </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">PUM </td><td align="center">18 </td><td align="left"><b>Protect User Memory</b> bit modifies the privilege with which loads access virtual memory </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">MPRV </td><td align="center">17 </td><td align="left">Privilege level at which loads and stores execute </td></tr>
<tr>
<td align="center">2 </td><td align="center">RW </td><td align="center">2h'0 </td><td align="left">XS </td><td align="center">16:15 </td><td align="left">Context switch reducing flags: 0=All Off; 1=None dirty or clean, some on; 2=None dirty, some clean; 3=Some dirty </td></tr>
<tr>
<td align="center">2 </td><td align="center">RW </td><td align="center">2h'0 </td><td align="left">FS </td><td align="center">14:13 </td><td align="left">Context switch reducing flags: 0=Off; 1=Initial; 2=Clean; 3=Dirty </td></tr>
<tr>
<td align="center">2 </td><td align="center">RW </td><td align="center">2h'0 </td><td align="left">MPP </td><td align="center">12:11 </td><td align="left">Priviledge mode on MRET </td></tr>
<tr>
<td align="center">2 </td><td align="center">RW </td><td align="center">2h'0 </td><td align="left">HPP </td><td align="center">10:9 </td><td align="left">Priviledge mode on HRET </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">SPP </td><td align="center">8 </td><td align="left">Priviledge mode on SRET </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">MPIE </td><td align="center">7 </td><td align="left">MIE prior to the trap </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">HPIE </td><td align="center">6 </td><td align="left">HIE prior to the trap </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">SPIE </td><td align="center">5 </td><td align="left">SIE prior to the trap </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">UPIE </td><td align="center">4 </td><td align="left">UIE prior to the trap </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">MIE </td><td align="center">3 </td><td align="left">Machine interrupt enable bit </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">HIE </td><td align="center">2 </td><td align="left">Hypervisor interrupt enable bit </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">SIE </td><td align="center">1 </td><td align="left">Super-user interrupt enable bit </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">UIE </td><td align="center">0 </td><td align="left">User interrupt enable bit </td></tr>
</table>
<dl class="section user"><dt>Machine Trap-Vector Base-Address Register (0x01828). ISA offset 0x305.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="left">Definition  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">mtvec </td><td align="left"><b>Trap-vector Base Address</b>. The mtvec register is an XLEN-bit read/write register that holds the base address of the M-mode trap vector. </td></tr>
</table>
<dl class="section user"><dt>Machine Exception Program Counter (0x01A08). ISA offset 0x341.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="left">Definition  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">mepc </td><td align="left"><b>Machine mode exception program counter</b>. Instruction MRET is used to return from traps in User Mode into specified instruction pointer. On implementations that do not support instruction-set extensions with 16-bit instruction alignment, the two low bits (mepc[1:0]) are always zero. </td></tr>
</table>
<dl class="section user"><dt>Machine Cause Register (0x01A10). ISA offset 0x342.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name </th><th align="center">Bits</th><th align="left">Definition  </th></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="left">Interrupt </td><td align="center">63 </td><td align="left">The Interrupt bit is set if the trap was caused by an interrupt. </td></tr>
<tr>
<td align="center">63 </td><td align="center">RW </td><td align="center">63h'0 </td><td align="left">Exception Code </td><td align="center">62:0 </td><td align="left"><b>Exception code</b>. The Exception Code field contains a code identifying the last exception. Table 3.6 lists the possible machine-level exception codes. </td></tr>
</table>
<dl class="section user"><dt>Machine Cause Register (0x01A18). ISA offset 0x343.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name </th><th align="center">Bits</th><th align="left">Definition  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="left">mbadaddr </td><td align="center">63:0 </td><td align="left"><b>Exception address</b>. When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned or access exception occurs, mbadaddr is written with the faulting address. mbadaddr is not modified for other exceptions. </td></tr>
</table>
<dl class="section user"><dt>Machine ISA Register (0x07880). ISA offset 0xf10.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">2 </td><td align="center">RO </td><td align="center">2h'2 </td><td align="left">Base (WARL)</td><td align="center">63:62 </td><td align="left"><b>Integer ISA width</b>: 1=32 bits; 2=64 bits; 3=128 bits. </td></tr>
<tr>
<td align="center">34 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="left">WIRI </td><td align="center">61:28 </td><td align="left">Reserved. </td></tr>
<tr>
<td align="center">28 </td><td align="center">RO </td><td align="center">28h'141181 </td><td align="left">Extension (WARL) </td><td align="center">27:0 </td><td align="left"><b>Supported ISA extensions</b>. See priviledge-isa datasheet. </td></tr>
</table>
<dl class="section user"><dt>Machine Vendor ID (0x07888). ISA offset 0xf11.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="left">Vendor </td><td align="center">63:0 </td><td align="left"><b>Vendor ID</b>. read-only register encoding the manufacturer of the part. This register must be readable in any implementation, but a value of 0 can be returned to indicate the field is not implemented or that this is a non-commercial implementation. </td></tr>
</table>
<dl class="section user"><dt>Machine Architecture ID Register (0x07890). ISA offset 0xf12.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="left">marchid </td><td align="center">63:0 </td><td align="left"><b>Architecture ID</b>. Read-only register encoding the base microarchitecture of the hart. This register must be readable in any implementation, but a value of 0 can be returned to indicate the field is not implemented. The combination of mvendorid and marchid should uniquely identify the type of hart microarchitecture that is implemented. </td></tr>
</table>
<dl class="section user"><dt>Machine implementation ID Register (0x07898). ISA offset 0xf13.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="left">mimplid </td><td align="center">63:0 </td><td align="left"><b>Implementation ID</b>. CSR provides a unique encoding of the version of the processor implementation. This register must be readable in any implementation, but a value of 0 can be returned to indicate that the field is not implemented. </td></tr>
</table>
<dl class="section user"><dt>Hart ID Register (0x078A0). ISA offset 0xf14.</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="left">Field Name</th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="left">mhartid </td><td align="center">63:0 </td><td align="left"><b>Integer ID of hardware thread</b>. Hart IDs mightnot necessarily be numbered contiguously in a multiprocessor system, but at least one hart musthave a hart ID of zero. </td></tr>
</table>
<h2><a class="anchor" id="dsu_iregs"></a>
General CPU Registers Region (32 KB)</h2>
<dl class="section user"><dt>CPU integer registers (0x08000).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="left">Offset </th><th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Name </th><th>Definition  </th></tr>
<tr>
<td align="left">0x08000</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">zero </td><td><b>x0</b>. CPU General Integer Register hardware connected to zero. </td></tr>
<tr>
<td align="left">0x08008</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">ra </td><td><b>x1</b>. Return address. </td></tr>
<tr>
<td align="left">0x08010</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">sp </td><td><b>x2</b>. Stack pointer. </td></tr>
<tr>
<td align="left">0x08018</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">gp </td><td><b>x3</b>. Global pointer. </td></tr>
<tr>
<td align="left">0x08020</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">tp </td><td><b>x4</b>. Thread pointer. </td></tr>
<tr>
<td align="left">0x08028</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t0 </td><td><b>x5</b>. Temporaries 0. </td></tr>
<tr>
<td align="left">0x08030</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t1 </td><td><b>x6</b>. Temporaries 1. </td></tr>
<tr>
<td align="left">0x08038</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t2 </td><td><b>x7</b>. Temporaries 2. </td></tr>
<tr>
<td align="left">0x08040</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s0/fp</td><td><b>x8</b>. CPU General Integer Register 'Saved register 0/ Frame pointer'. </td></tr>
<tr>
<td align="left">0x08048</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s1 </td><td><b>x9</b>. Saved register 1. </td></tr>
<tr>
<td align="left">0x08050</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a0 </td><td><b>x10</b>. Function argument 0. It is also used to save return value. </td></tr>
<tr>
<td align="left">0x08058</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a1 </td><td><b>x11</b>. Function argument 1. </td></tr>
<tr>
<td align="left">0x08060</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a2 </td><td><b>x12</b>. Function argument 2. </td></tr>
<tr>
<td align="left">0x08068</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a3 </td><td><b>x13</b>. Function argument 3. </td></tr>
<tr>
<td align="left">0x08070</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a4 </td><td><b>x14</b>. Function argument 4. </td></tr>
<tr>
<td align="left">0x08078</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a5 </td><td><b>x15</b>. Function argument 5. </td></tr>
<tr>
<td align="left">0x08080</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a6 </td><td><b>x16</b>. Function argument 6. </td></tr>
<tr>
<td align="left">0x08088</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">a7 </td><td><b>x17</b>. Function argument 7. </td></tr>
<tr>
<td align="left">0x08090</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s2 </td><td><b>x18</b>. Saved register 2. </td></tr>
<tr>
<td align="left">0x08098</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s3 </td><td><b>x19</b>. Saved register 3. </td></tr>
<tr>
<td align="left">0x080a0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s4 </td><td><b>x20</b>. Saved register 4. </td></tr>
<tr>
<td align="left">0x080a8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s5 </td><td><b>x21</b>. Saved register 5. </td></tr>
<tr>
<td align="left">0x080b0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s6 </td><td><b>x22</b>. Saved register 6. </td></tr>
<tr>
<td align="left">0x080b8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s7 </td><td><b>x23</b>. Saved register 7. </td></tr>
<tr>
<td align="left">0x080c0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s8 </td><td><b>x24</b>. Saved register 8. </td></tr>
<tr>
<td align="left">0x080c8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s9 </td><td><b>x25</b>. Saved register 9. </td></tr>
<tr>
<td align="left">0x080d0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s10 </td><td><b>x26</b>. Saved register 10. </td></tr>
<tr>
<td align="left">0x080d8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">s11 </td><td><b>x27</b>. Saved register 11. </td></tr>
<tr>
<td align="left">0x080e0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t3 </td><td><b>x28</b>. Temporaries 3. </td></tr>
<tr>
<td align="left">0x080e8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t4 </td><td><b>x29</b>. Temporaries 4. </td></tr>
<tr>
<td align="left">0x080f0</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t5 </td><td><b>x30</b>. Temporaries 5. </td></tr>
<tr>
<td align="left">0x080f8</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">t6 </td><td><b>x31</b>. Temporaries 6. </td></tr>
<tr>
<td align="left">0x08100</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">pc </td><td><b>Instruction pointer</b>. Cannot be modified because shows the latest executed instruction address </td></tr>
<tr>
<td align="left">0x08108</td><td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">npc </td><td><b>Next Instruction Pointer</b> </td></tr>
</table>
<h2><a class="anchor" id="dsu_control"></a>
Run Control and Debug support Region (32 KB)</h2>
<dl class="section user"><dt>Run control/status registers (0x10000).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">44 </td><td align="center">RW </td><td align="center">61h'0 </td><td align="center">Reserved </td><td align="center">63:6 </td><td align="left">Reserved. </td></tr>
<tr>
<td align="center">16 </td><td align="center">RO </td><td align="center">16h'0 </td><td align="center">core_id </td><td align="center">15:4 </td><td align="left"><b>Core ID</b>. </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="center">Reserved </td><td align="center">3 </td><td align="left">Reserved. </td></tr>
<tr>
<td align="center">1 </td><td align="center">RO </td><td align="center">1b'0 </td><td align="center">breakpoint </td><td align="center">2 </td><td align="left"><b>Breakpoint</b>. Status bit is set when CPU was halted due the EBREAK instruction. </td></tr>
<tr>
<td align="center">1 </td><td align="center">WO </td><td align="center">1b'0 </td><td align="center">stepping_mode </td><td align="center">1 </td><td align="left"><b>Stepping mode</b>. This bit enables stepping mode if the Register 'steps' is non zero. </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="center">halt </td><td align="center">0 </td><td align="left"><b>Halt mode</b>. When this bit is set CPU pipeline is in the halted state. CPU can be halted at any time without impact on processing data. </td></tr>
</table>
<dl class="section user"><dt>Stepping mode Steps registers (0x10008).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">steps </td><td align="center">63:0 </td><td align="left"><b>Step counter</b>. Total number of instructions that should execute CPU before halt. CPU is set into stepping using 'stepping mode' bit in Run Control register. </td></tr>
</table>
<dl class="section user"><dt>Clock counter registers (0x10010).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">clock_cnt </td><td align="center">63:0 </td><td align="left"><b>Clock counter</b>. Clock counter is used for hardware computation of CPI rate. Clock counter isn't incrementing in Halt state. </td></tr>
</table>
<dl class="section user"><dt>Step counter registers (0x10018).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">executed_cnt </td><td align="center">63:0 </td><td align="left"><b>Step counter</b>. Total number of executed instructions. Step counter is used for hardware computation of CPI rate. </td></tr>
</table>
<dl class="section user"><dt>Breakpoint Control registers (0x10020).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">63 </td><td align="center">RW </td><td align="center">63h'0 </td><td align="center">Reserved </td><td align="center">63:1 </td><td align="left">Reserved </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="center">trap_on_break </td><td align="center">0 </td><td align="left"><b>Trap On Break</b>. Generate exception 'Breakpoint' on EBRAK instruction if this bit is set or just Halt the pipeline otherwise. </td></tr>
</table>
<dl class="section user"><dt>Add hardware breakpoint registers (0x10028).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">add_break </td><td align="center">63:0 </td><td align="left"><b>Add HW breakpoint address</b>. Add specified address into Hardware breakpoint stack. In case of matching Instruction Pointer (pc) and any HW breakpoint there's injected EBREAK instruction on hardware level. </td></tr>
</table>
<dl class="section user"><dt>Remove hardware breakpoint registers (0x10030).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">rem_break </td><td align="center">63:0 </td><td align="left"><b>Remove HW breakpoint address</b>. Remove specified address from Hardware breakpoints stack. </td></tr>
</table>
<dl class="section user"><dt>Breakpoint Address Fetch registers (0x10038).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">br_address_fetch </td><td align="center">63:0 </td><td align="left"><b>Breakpoint fetch address</b>. Specify address that will be ignored by Fetch stage and used Breakpoint Fetch Instruction value instead. This logic is used to avoid re-writing EBREAK into memory. </td></tr>
</table>
<dl class="section user"><dt>Breakpoint Instruction Fetch registers (0x10040).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RW </td><td align="center">64h'0 </td><td align="center">br_instr_fetch </td><td align="center">63:0 </td><td align="left"><b>Breakpoint fetch instruction</b>. Specify instruction that should executed instead of fetched from memory in a case of matching Breapoint Address Fetch register and Instruction pointer (pc). </td></tr>
</table>
<h2><a class="anchor" id="dsu_local"></a>
Local DSU Region (32 KB)</h2>
<dl class="section user"><dt>Soft Reset registers (0x18000).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">63 </td><td align="center">RW </td><td align="center">63h'0 </td><td align="center">Reserved </td><td align="center">63:1 </td><td align="left">Reserved. </td></tr>
<tr>
<td align="center">1 </td><td align="center">RW </td><td align="center">1b'0 </td><td align="center">soft_reset </td><td align="center">0 </td><td align="left"><b>Soft Reset</b>. Status bit is set when CPU was halted due the EBREAK instruction. </td></tr>
</table>
<dl class="section user"><dt>Miss Access counter registers (0x18008).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">miss_access_cnt </td><td align="center">63:0 </td><td align="left"><b>Miss Access counter</b>. This value as an additional debugging informantion provided by AXI Controller. It is possible to enable interrupt generation in Interrupt Controller on miss-access. </td></tr>
</table>
<dl class="section user"><dt>Miss Access Address registers (0x18010).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Field Name </th><th align="center">Bits </th><th align="left">Description  </th></tr>
<tr>
<td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">miss_access_addr </td><td align="center">63:0 </td><td align="left"><b>Miss Access address</b>. Address of the latest miss-accessed transaction. This information comes from AXI Controller. </td></tr>
</table>
<dl class="section user"><dt>Bus Utilization registers (0x18040 + n*2*sizeof(uint64_t)).</dt><dd></dd></dl>
<table class="doxtable">
<tr>
<th align="left">Offset </th><th align="center">Bits</th><th align="center">Type</th><th align="center">Reset </th><th align="center">Name </th><th>Definition  </th></tr>
<tr>
<td align="left">0x18040</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">w_cnt </td><td><b>Write transactions counter for master 0</b>. Master 0 is the RIVER CPU by default. </td></tr>
<tr>
<td align="left">0x18048</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">r_cnt </td><td><b>Read transactions counter for master 0</b>. </td></tr>
<tr>
<td align="left">0x18050</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">w_cnt </td><td><b>Write transactions counter for master 1</b>. Master 1 is unused in a case of configuration with RIVER CPU. </td></tr>
<tr>
<td align="left">0x18058</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">r_cnt </td><td><b>Read transactions counter for master 1</b>. </td></tr>
<tr>
<td align="left">0x18060</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">w_cnt </td><td><b>Write transactions counter for master 2</b>. Master 2 is the GRETH by default (Ethernet Controller with master interface). </td></tr>
<tr>
<td align="left">0x18068</td><td align="center">64 </td><td align="center">RO </td><td align="center">64h'0 </td><td align="center">r_cnt </td><td><b>Read transactions counter for master 2</b>. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
